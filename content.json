{"meta":{"title":"Qing的前端开发Blog","subtitle":null,"description":"Web前端开发文档整理","author":"WalkStreet","url":"https://walkstreet.github.io/personal-blog"},"pages":[{"title":"about","date":"2017-05-16T03:16:36.000Z","updated":"2018-02-23T09:47:02.460Z","comments":true,"path":"about/index.html","permalink":"https://walkstreet.github.io/personal-blog/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-03-27T06:54:41.000Z","updated":"2018-02-23T09:47:02.460Z","comments":true,"path":"categories/index.html","permalink":"https://walkstreet.github.io/personal-blog/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"React组件间通信","slug":"react-components-context","date":"2018-05-19T13:53:17.000Z","updated":"2018-05-19T14:03:05.613Z","comments":true,"path":"2018/05/19/react-components-context/","link":"","permalink":"https://walkstreet.github.io/personal-blog/personal-blog/2018/05/19/react-components-context/","excerpt":"前言关于组件化开发规范，希望申明一个原则——能不用Redux就不要使用Redux解决。在普通开发中遇到父子组件通信时，需要考虑通过传统Props和子组件的回调来解决基本通信，今天主要整理关于组件通信的解决方案 父组件向子组件通信父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。1234567891011121314.....import Sub from &apos;Sub.js&apos;; // 子组件class Container extends React.Component&#123; constructor()&#123; super(); &#125; render()&#123; return ( &lt;Sub title=&quot;评论列表&quot; // 通过属性传递 name=&#123;&quot;xx&quot;&#125; /&gt; ); &#125;&#125; 子组件向父组件通信利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。123456789101112131415161718&lt;Container.js&gt;.....import Sub from &apos;Sub.js&apos;;class Container extends React.Component&#123; constructor()&#123; super(); &#125; getChildMsg(msg)&#123; console.log(&quot;子组件给父组件通信内容： &quot;+msg); &#125; render()&#123; return ( &lt;Sub title=&quot;评论列表&quot; callback=&#123;this.getChildMsg.bind(this)&#125; // 将回调函数传给子组件 /&gt; ); &#125;&#125;","text":"前言关于组件化开发规范，希望申明一个原则——能不用Redux就不要使用Redux解决。在普通开发中遇到父子组件通信时，需要考虑通过传统Props和子组件的回调来解决基本通信，今天主要整理关于组件通信的解决方案 父组件向子组件通信父组件通过向子组件传递 props，子组件得到 props 后进行相应的处理。1234567891011121314.....import Sub from &apos;Sub.js&apos;; // 子组件class Container extends React.Component&#123; constructor()&#123; super(); &#125; render()&#123; return ( &lt;Sub title=&quot;评论列表&quot; // 通过属性传递 name=&#123;&quot;xx&quot;&#125; /&gt; ); &#125;&#125; 子组件向父组件通信利用回调函数，可以实现子组件向父组件通信：父组件将一个函数作为 props 传递给子组件，子组件调用该回调函数，便可以向父组件通信。123456789101112131415161718&lt;Container.js&gt;.....import Sub from &apos;Sub.js&apos;;class Container extends React.Component&#123; constructor()&#123; super(); &#125; getChildMsg(msg)&#123; console.log(&quot;子组件给父组件通信内容： &quot;+msg); &#125; render()&#123; return ( &lt;Sub title=&quot;评论列表&quot; callback=&#123;this.getChildMsg.bind(this)&#125; // 将回调函数传给子组件 /&gt; ); &#125;&#125; 1234567891011121314151617181920&lt;Sub.js&gt;.....class Sub extends React.Component&#123; constructor(props)&#123; super(props); this.onOk=this.onOk.bind(this); &#125; onOk()&#123; this.props.callback(&quot;sub&quot;); // 回调函数 &#125; render()&#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.onOk&#125;&gt;&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;exprot default Sub; 跨级组件之间的通信所谓跨级组件通信，就是父组件向子组件的子组件通信，向更深层的子组件通信。跨级组件通信可以采用下面两种方式：1、使用 context 对象 父组件12345678910111213141516171819201.声明自己支持的context，并且提供context中属性的PropType. 声明： static childContextTypes=&#123; name： PropTypes.string, // 需要传入给子组件的参数 getData: PropTypes.func, arr: PropTypes.array &#125; 2. 提供一个getChildContext函数，返回一个初始化的context对象 返回context对象： getChildContext()&#123; return&#123; name: this.state.name, arr : this.props.array, getData: this.getData.bind(this) &#125; &#125; 3. 回调函数 getData(data)&#123; console.log(data);// data 为子组件传给父组件的回调 &#125; 子组件：1234567891. 声明自己需要使用的context static contextTypes=&#123; name： PropTypes.string, getData: PropTypes.func &#125; 2. 使用context var name = this.context.name; var str = &quot;把这个值传递给父级&quot;； this.context.getData(str); 注意事项：1234567891011121314151617181920212223242526271. 在组件中如果有constructor,在构造函数中，应该将context传入 constructor(props, context)&#123; super(props, context); &#125; 2. 改变context对象 3. context在无状态组件中的用法 const Sub =(props, context)=&gt;&#123; var name = context.name; context.getData(&quot;回调传参&quot;); retrun( &lt;div&gt;....&lt;/div&gt; ); &#125; Sub.contextTypes=&#123; name: PropTypes.string, getData: PropTypes.func 4. context 在生命周期中的用法 constructor(props, context) componentWillReceiveProps(nextProps, nextContext) shouldComponentUpdate(nextProps, nextState, nextContext) componentWillUpdate(nextProps, nextState, nextContext) componentDidUpdate(prevProps, prevState, prevContext) 5. 根据react的组件层级，一个组件可以有多个父级，可以同时声明在不通父级中要使用的context 2、中间组件层层传递 props12345678910111213141516171819202122232425App.js render()&#123; return( &lt;Sub name=&quot;test&quot; sendData=&#123;this.sendData.bind(this)&#125; /&gt; ); &#125;;Sub.js render()&#123; return( &lt;SubSub name=&#123;this.props.name&#125; sendData=&#123;this.props.sendData&#125; /&gt; ); &#125;; SubSub.js .... var name = this.props.name; this.props.sendData(&quot;App回调&quot;); ... 非嵌套组件间通信1、同context2、Redux！！！！！！！","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://walkstreet.github.io/personal-blog/categories/Javascript/"}],"tags":[{"name":"React","slug":"React","permalink":"https://walkstreet.github.io/personal-blog/tags/React/"}]},{"title":"es6里的__proto__ 属性,Object.setPrototypeOf(),Object.getPrototypeOf()","slug":"es6里的-proto-属性Object-setPrototypeOf-Object-getPrototypeOf","date":"2017-06-23T09:20:33.000Z","updated":"2018-02-23T09:47:02.457Z","comments":true,"path":"2017/06/23/es6里的-proto-属性Object-setPrototypeOf-Object-getPrototypeOf/","link":"","permalink":"https://walkstreet.github.io/personal-blog/personal-blog/2017/06/23/es6里的-proto-属性Object-setPrototypeOf-Object-getPrototypeOf/","excerpt":"（ 1 ）proto 属性proto属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括 IE11 ）都部署了这个属性。 12345678// es6 的写法 var obj = &#123; method: function() &#123; ... &#125; &#125;; obj.__proto__ = someOtherObj; // es5 的写法 var obj = Object.create(someOtherObj); obj.method = function() &#123; ... &#125;; 该属性没有写入 ES6 的正文，而是写入了附录，原因是proto前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API ，只是由于浏览器广泛支持，才被加入了 ES6 。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。在实现上，proto调用的是Object.prototype.proto，具体实现如下。 123456789101112131415161718192021222324Object.defineProperty(Object.prototype, &apos;__proto__&apos;, &#123; get() &#123; let _thisObj = Object(this); return Object.getPrototypeOf(_thisObj); &#125;, set(proto) &#123; if (this === undefined || this === null) &#123; throw new TypeError(); &#125; if (!isObject(this)) &#123; return undefined; &#125; if (!isObject(proto)) &#123; return undefined; &#125; let status = Reflect.setPrototypeOf(this, proto); if (!status) &#123; throw new TypeError(); &#125; &#125;, &#125;); function isObject(value) &#123; return Object(value) === value; &#125; 如果一个对象本身部署了proto属性，则该属性的值就是对象的原型。 12Object.getPrototypeOf(&#123; __proto__: null &#125;) // null","text":"（ 1 ）proto 属性proto属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括 IE11 ）都部署了这个属性。 12345678// es6 的写法 var obj = &#123; method: function() &#123; ... &#125; &#125;; obj.__proto__ = someOtherObj; // es5 的写法 var obj = Object.create(someOtherObj); obj.method = function() &#123; ... &#125;; 该属性没有写入 ES6 的正文，而是写入了附录，原因是proto前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API ，只是由于浏览器广泛支持，才被加入了 ES6 。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。在实现上，proto调用的是Object.prototype.proto，具体实现如下。 123456789101112131415161718192021222324Object.defineProperty(Object.prototype, &apos;__proto__&apos;, &#123; get() &#123; let _thisObj = Object(this); return Object.getPrototypeOf(_thisObj); &#125;, set(proto) &#123; if (this === undefined || this === null) &#123; throw new TypeError(); &#125; if (!isObject(this)) &#123; return undefined; &#125; if (!isObject(proto)) &#123; return undefined; &#125; let status = Reflect.setPrototypeOf(this, proto); if (!status) &#123; throw new TypeError(); &#125; &#125;, &#125;); function isObject(value) &#123; return Object(value) === value; &#125; 如果一个对象本身部署了proto属性，则该属性的值就是对象的原型。 12Object.getPrototypeOf(&#123; __proto__: null &#125;) // null （ 2 ） Object.setPrototypeOf()Object.setPrototypeOf方法的作用与proto相同，用来设置一个对象的prototype对象。它是 ES6 正式推荐的设置原型对象的方法。 123456789101112131415161718// 格式 Object.setPrototypeOf(object, prototype) // 用法 var o = Object.setPrototypeOf(&#123;&#125;, null); //该方法等同于下面的函数。 function (obj, proto) &#123; obj.__proto__ = proto; return obj; &#125; //下面是一个例子。 let proto = &#123;&#125;; let obj = &#123; x: 10 &#125;; Object.setPrototypeOf(obj, proto); proto.y = 20; proto.z = 40; obj.x // 10 obj.y // 20 obj.z // 40 上面代码将 proto 对象设为 obj 对象的原型，所以从 obj 对象可以读取 proto 对象的属性。（ 3 ） Object.getPrototypeOf()该方法与 setPrototypeOf 方法配套，用于读取一个对象的 prototype 对象。 12345678910Object.getPrototypeOf(obj); //下面是一个例子。 function Rectangle() &#123; &#125; var rec = new Rectangle(); Object.getPrototypeOf(rec) === Rectangle.prototype // true Object.setPrototypeOf(rec, Object.prototype); Object.getPrototypeOf(rec) === Rectangle.prototype // false","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://walkstreet.github.io/personal-blog/categories/Javascript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://walkstreet.github.io/personal-blog/tags/ES6/"},{"name":"类","slug":"类","permalink":"https://walkstreet.github.io/personal-blog/tags/类/"}]},{"title":"浅谈super如何实现","slug":"浅谈super如何实现","date":"2017-06-23T09:13:31.000Z","updated":"2018-02-23T09:47:02.459Z","comments":true,"path":"2017/06/23/浅谈super如何实现/","link":"","permalink":"https://walkstreet.github.io/personal-blog/personal-blog/2017/06/23/浅谈super如何实现/","excerpt":"","text":"应该是super关键字只能在class内部使用，外部直接调用就会出错，因为你根本不知道父类的构造函数是那个啊。它们只是语法糖而已，JavaScript仍然是基于原型的继承，super本质上就是借用构造函数的一种表现形式，我们可以通过如下清楚看出来。 原始的class实现方法 12345678910111213141516171819202122function Parent(name) &#123; this.name = name;&#125;Parent.prototype.getName = function() &#123; return this.name;&#125;function Child(name, age) &#123; //借用构造函数 Parent.call(this, name); this.age = age;&#125;//实现继承Child.prototype = new Parent();Child.prototype.constructor = Child;Child.prototype.getAge = function()&#123; return this.Age;&#125;;var people = new Child(&quot;lily&quot;, 20);console.log(people.getName()); 语法糖 123456789101112131415161718192021class Parent &#123; constructor(name) &#123; this.name = name; &#125; getName() &#123; return this.name; &#125;&#125;class Child extends Parent &#123; constructor(name, age) &#123; super(name); this.age = age; &#125; getAge() &#123; return this.age; &#125;&#125;const people = new Child(&quot;lily&quot;, 20);console.log(people.getName());","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://walkstreet.github.io/personal-blog/categories/Javascript/"}],"tags":[{"name":"super","slug":"super","permalink":"https://walkstreet.github.io/personal-blog/tags/super/"}]},{"title":"面向对象的Javascript-了解ES6类","slug":"面向对象的Javascript","date":"2017-06-22T09:01:43.000Z","updated":"2018-02-23T09:47:02.459Z","comments":true,"path":"2017/06/22/面向对象的Javascript/","link":"","permalink":"https://walkstreet.github.io/personal-blog/personal-blog/2017/06/22/面向对象的Javascript/","excerpt":"概述non-class（非类）代码1234567891011121314151617// set today to December 24let today = &#123; month: 12, day: 24,&#125;; let tomorrow = &#123; year: today.year, month: today.month, day: today.day + 1,&#125;; let dayAfterTomorrow = &#123; year: tomorrow.year, month: tomorrow.month, day: tomorrow.day + 1 &lt; = 31 ? tomorrow.day + 1 : 1,&#125;; 日期 today 有一些问题，year 丢失了，如果我们有一个不能被遗忘的初始化函数会更好。另请注意，当加 1 天时，我们检查了一个地方，如果我们超过 31 日，但没有检查其他地方。所以，如果我们只通过一组固定的函数与数据交互，并且维护每个有效状态，这样才能更好。 这是使用类后的更正版本。 1234567891011121314151617181920212223242526class SimpleDate &#123; constructor(year, month, day) &#123; // 检查 (year, month, day) 是否为一个有效的日期 // ... // 如果是, 使用她来初始化 &quot;this&quot; 的日期 this._year = year; this._month = month; this._day = day; &#125; addDays(nDays) &#123; // 增加 &quot;this&quot; 日期 // ... &#125; getDay() &#123; return this._day; &#125;&#125; // &quot;today&quot; 被保证是有效和完全初始化的let today = new SimpleDate(2000, 2, 28); // 仅通过一组固定的函数操作数据，确保我们保持有效状态today.addDays(1); 提示： 当函数与类或对象相关联时，我们将其称为“方法”。 当从一个类创建对象时，该对象被认为是该类的“实例”。","text":"概述non-class（非类）代码1234567891011121314151617// set today to December 24let today = &#123; month: 12, day: 24,&#125;; let tomorrow = &#123; year: today.year, month: today.month, day: today.day + 1,&#125;; let dayAfterTomorrow = &#123; year: tomorrow.year, month: tomorrow.month, day: tomorrow.day + 1 &lt; = 31 ? tomorrow.day + 1 : 1,&#125;; 日期 today 有一些问题，year 丢失了，如果我们有一个不能被遗忘的初始化函数会更好。另请注意，当加 1 天时，我们检查了一个地方，如果我们超过 31 日，但没有检查其他地方。所以，如果我们只通过一组固定的函数与数据交互，并且维护每个有效状态，这样才能更好。 这是使用类后的更正版本。 1234567891011121314151617181920212223242526class SimpleDate &#123; constructor(year, month, day) &#123; // 检查 (year, month, day) 是否为一个有效的日期 // ... // 如果是, 使用她来初始化 &quot;this&quot; 的日期 this._year = year; this._month = month; this._day = day; &#125; addDays(nDays) &#123; // 增加 &quot;this&quot; 日期 // ... &#125; getDay() &#123; return this._day; &#125;&#125; // &quot;today&quot; 被保证是有效和完全初始化的let today = new SimpleDate(2000, 2, 28); // 仅通过一组固定的函数操作数据，确保我们保持有效状态today.addDays(1); 提示： 当函数与类或对象相关联时，我们将其称为“方法”。 当从一个类创建对象时，该对象被认为是该类的“实例”。 构造函数constructor 方法是指定的，它解决了第一个问题。它的工作是将一个实例初始化为一个有效的状态，它将被自动调用，所以我们不需要记住初始化我们的对象。 保持数据私有我们试图设计我们的类，使他们的状态始终保存有效。我们提供一个只创建有效值的构造函数，并且我们设计的方法也总是只保留有效值。但是，只要我们把类的所有数据让大家可访问，那么有人会把它弄乱。除了通过我们提供的函数外，我们需要保护数据不可被访问。 提示：保护数据不被\b访问，称为“封装”。 通过公约实现属性私有化不幸的是，JavaScript 中不存在私有的对象属性。我们要伪装他们。最常见的方法是遵守一个简单的惯例：在属性名称前加下划线（或者较不常见的是用下划线做后缀），那么它应该被视为是非公开的。我们在早期的代码示例中\b通常都使用这种方法。一般来说，这个简单的惯例能工作，但数据在技术上仍然可供大家使用，所以我们要靠自己的规范去做正确的事情。 通过特权方法实现属性私有化下一个最常见的方式是伪装私有对象属性，在构造函数中使用普通变量来，并在闭包中捕获他们。这个技巧给我们真正的私有数据，外部无法访问。但为了使其工作，我们的类的方法本身需要在构造函数中定义并附加到实例。 123456789101112131415161718192021class SimpleDate &#123; constructor(year, month, day) &#123; // 检查 (year, month, day) 是否为一个有效的日期 // ... // 如果是, 使用她来初始化 &quot;this&quot; 日期的\b\b普通变量 let _year = year; let _month = month; let _day = day; // 在构造函数中定义的方法捕获闭包中的变量 this.addDays = function(nDays) &#123; // 增加 &quot;this&quot; 日期 // ... &#125; this.getDay = function() &#123; return _day; &#125; &#125;&#125; 通过 Symbol 实现属性私有化Symbol 是 JavaScript 的新功能，他们给我们带来了另一种\b伪装私有对象属性的方法。代替带下划线的属性名称，我们可以使用唯一的 symbol 对象键，我们的 class(类) 可以在闭包中中捕获这些键。但是有一个漏洞，JavaScript 的另一个新功能是 Object.getOwnPropertySymbols，它允许外部访问我们试图保持私有的 symbol 键。 12345678910111213141516171819202122232425262728let SimpleDate = (function() &#123; let _yearKey = Symbol(); let _monthKey = Symbol(); let _dayKey = Symbol(); class SimpleDate &#123; constructor(year, month, day) &#123; // 检查 (year, month, day) 是否为一个有效的日期 // ... // 如果是, 使用她来初始化 &quot;this&quot; 日期 this[_yearKey] = year; this[_monthKey] = month; this[_dayKey] = day; &#125; addDays(nDays) &#123; // 增加 &quot;this&quot; 日期 // ... &#125; getDay() &#123; return this[_dayKey]; &#125; &#125; return SimpleDate;&#125;()); 通过 WeakMap 实现属性私有化WeakMap 也是 JavaScript 的新功能。我们可以在使用我们的实例的作为 key 的键/值对中存储私有对象属性，并且我们的 class(类) 可以在闭包中中捕获这些键/值映射。 12345678910111213141516171819202122232425262728let SimpleDate = (function() &#123; let _years = new WeakMap(); let _months = new WeakMap(); let _days = new WeakMap(); class SimpleDate &#123; constructor(year, month, day) &#123; // 检查 (year, month, day) 是否为一个有效的日期 // ... // 如果是, 使用她来初始化 &quot;this&quot; 日期 _years.set(this, year); _months.set(this, month); _days.set(this, day); &#125; addDays(nDays) &#123; // 增加 &quot;this&quot; 日期 // ... &#125; getDay() &#123; return _days.get(this); &#125; &#125; return SimpleDate;&#125;()); 其他访问修饰符除了 “private” 之外，你会发现其他语言还有其他级别的属性可见性，如 “protected”, “internal”, “package private”, 或者 “friend”。JavaScript 仍然没有给我们一种方法来强制执行其他级别的可见性。如果你需要它们，你必须依靠公约和规范。 引用当前对象再看一下 getDay()。它没有指定任何参数，那么它怎么知道它所调用的对象呢？当函数被作为方法调用时，使用 object.function 表示法，他有一个隐含的参数，用来标识对象，并将该隐式 argument 分配给一个名为 this 的隐式 parameter 。为了说明这一点，我们将明确地而不是隐式地发送对象参数。 1234567// 引用 “getDay” 函数let getDay = SimpleDate.prototype.getDay; getDay.call(today); // &quot;this&quot; 指向 &quot;today&quot;getDay.call(tomorrow); // &quot;this&quot; 指向 &quot;tomorrow&quot; tomorrow.getDay(); // 与上一行相同，但是 &quot;tomorrow&quot; 被隐式地传递 静态属性和方法我们有选择可以定义属性和函数，作为类的一部分的，但不作为该类任何一个实例的一部分\b（\b愚人码头注：就是说该类的实例不可以访问这些属性和方法）。我们分别称这些为静态属性和静态方法。每个实例只有一个静态属性的副本，而不是一个新的副本。 12345678910111213141516171819202122232425262728293031323334353637383940class SimpleDate &#123; static setDefaultDate(year, month, day) &#123; // 静态属性可以引用，而实例不可以 // 相反，它在类上定义 SimpleDate._defaultDate = new SimpleDate(year, month, day); &#125; constructor(year, month, day) &#123; // 如果构造没有参数， // 然后通过复制静态默认日期来初始化“this”日期 if (arguments.length === 0) &#123; this._year = SimpleDate._defaultDate._year; this._month = SimpleDate._defaultDate._month; this._day = SimpleDate._defaultDate._day; return; &#125; // 检查 (year, month, day) 是否为一个有效的日期 // ... // 如果是, 使用她来初始化 &quot;this&quot; 日期 this._year = year; this._month = month; this._day = day; &#125; addDays(nDays) &#123; // 增加 &quot;this&quot; 日期 // ... &#125; getDay() &#123; return this._day; &#125;&#125; SimpleDate.setDefaultDate(1970, 1, 1); let defaultDate = new SimpleDate(); 子类我们经常会发现我们的类之间用共同点 – 重复的代码，我们想避免。子类让我们将另一个类的状态和行为合并到我们自己的类中。这个过程通常被称为“继承”，子类(subclass) 继承的父类，也称为超类(superclass)。继承可以避免重复并简化类的实现，比如当一个类需要使用另一个类相同的数据和函数\b时。继承还允许我们替换子类，只依靠一个共同的超类提供的接口。 继承避免重复考虑下面这段 non-inheritance(非继承) 实现的代码。 1234567891011121314151617181920212223242526class Employee &#123; constructor(firstName, familyName) &#123; this._firstName = firstName; this._familyName = familyName; &#125; getFullName() &#123; return `$&#123;this._firstName&#125; $&#123;this._familyName&#125;`; &#125;&#125; class Manager &#123; constructor(firstName, familyName) &#123; this._firstName = firstName; this._familyName = familyName; this._managedEmployees = []; &#125; getFullName() &#123; return `$&#123;this._firstName&#125; $&#123;this._familyName&#125;`; &#125; addEmployee(employee) &#123; this._managedEmployees.push(employee); &#125;&#125; 数据属性 _firstName 和 _familyName，和方法 getFullName 在我们的两个类上是重复的。我们可以让 Manager 类继承 Employee 类来消除这种重复。当我们这么做的时候，Employee 类的状态和行为（其数据和函数）将被并入我们的 Manager 类。 这是一个使用继承后的版本。 注意使用 super。 1234567891011// Manager 仍然可以跟上面的代码一样工作，但没有重复的代码class Manager extends Employee &#123; constructor(firstName, familyName) &#123; super(firstName, familyName); this._managedEmployees = []; &#125; addEmployee(employee) &#123; this._managedEmployees.push(employee); &#125;&#125; IS-A(是一个) 和 WORKS-LIKE-A(工作起来像什么)有个设计原则可以帮助您确定使用继承是否合适。继承应始终简历 IS-A(是一个) 和 WORKS-LIKE-A(工作起来像一个什么) 的关系模型。也就是说，Manager “IS-A(是一个)”，“WORKS-LIKE-A(工作起来像一个)”特定的 Employee ，这样，在我们使用超类实例的任何地方，应该都能够使用一个子类实例替换，并且所有的事情都应该仍然有效。有时，违反和遵守这一原则的区别是微妙的。一个微妙违反原则的典型例子是 Rectangle 超类和 Square 子类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Rectangle &#123; set width(w) &#123; this._width = w; &#125; get width() &#123; return this._width; &#125; set height(h) &#123; this._height = h; &#125; get height() &#123; return this._height; &#125;&#125; // 在 Rectangle(长方形) 实例上运行的函数function f(rectangle) &#123; rectangle.width = 5; rectangle.height = 4; // 验证预期结果 if (rectangle.width * rectangle.height !== 20) &#123; throw new Error(&quot;Expected the rectangle&apos;s area (width * height) to be 20&quot;); &#125;&#125; // 正方形 IS-A(是一个) 长方形... 对吗?class Square extends Rectangle &#123; set width(w) &#123; super.width = w; // 保持平方形 super.height = w; &#125; set height(h) &#123; super.height = h; // 保持平方形 super.width = h; &#125;&#125; // 但是可以用正方形代替长方形吗？f(new Square()); // error 一个正方形可以是数学上的长方形，但一个正方形在行为上不像长方形那样工作。 任何使用超类实例的地方，应该由一个子类实例来代替，这个规则称为里氏替代原则(Liskov Substitution principle)，它是面向对象类设计的重要组成部分。(\b愚人码头注：里氏替换原则的内容可以描述为： “派生类（子类）对象能够替换其基类（超类）对象被使用。” 来自维基百科) 当心过度使用在任何地方都很容易找到共同点，并且拥有一个提供完整功能的类的前景是很吸引人的，即使对于有经验的开发人员也是如此。但是继承也有缺点。回想一下，我们通过一组小的、固定的函数集来操纵数据，从而确保有效的状态。但是当我们使用继承时，我们增加了可以直接操作数据的一些函数，这些附加的函数也负责维护有效的状态。如果太多的函数可以直接操纵数据，那么数据几乎会和全局变量一样变得非常糟糕。过多的继承会创建单一的类，这些类会降低封装性，更难以纠正，更难以重用。相反，更喜欢设计只包含一个概念的最小类。 让我们再来看一下代码重复问题。我们不用继承可以解决它吗？另一种方法是通过引用来连接对象，以表示部分完整的关系。我们称之为“组合”。 这里是使用组合而不是继承的 manager-employee 的版本。 123456789101112131415161718192021class Employee &#123; constructor(firstName, familyName) &#123; this._firstName = firstName; this._familyName = familyName; &#125; getFullName() &#123; return `$&#123;this._firstName&#125; $&#123;this._familyName&#125;`; &#125;&#125; class Group &#123; constructor(manager /* : Employee */ ) &#123; this._manager = manager; this._managedEmployees = []; &#125; addEmployee(employee) &#123; this._managedEmployees.push(employee); &#125;&#125; 在这里，manager 不是一个单独的类。相反，一个 manager 是一个普通的 Employee 实例，Group 实例保持对其引用。如果继承模型是 IS-A(是一个) 关系，那么组合模型就是 HAS-A(有一个) 的关系。也就是说，一个 Group HAS-A(有一个) manager。（愚人码头注：更多概念可以阅读 JavaScript中的工厂函数 这篇文章。） 如果继承或组合可以合理地表达我们的程序概念和关系，那么更喜欢组合。 继承替换子类继承还允许不同的子类通过通用超类提供的接口来替换使用。期望超类实例作为参数的函数也可以传递一个子类实例，而这个函数不必知道任何子类。替换具有共同超类的类通常被称为“多态性”。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 这将是我们的共同超类class Cache &#123; get(key, defaultValue) &#123; let value = this._doGet(key); if (value === undefined || value === null) &#123; return defaultValue; &#125; return value; &#125; set(key, value) &#123; if (key === undefined || key === null) &#123; throw new Error(&apos;Invalid argument&apos;); &#125; this._doSet(key, value); &#125; // 必须重写 // _doGet() // _doSet()&#125; // 子类不定义新的公共方法// 公共接口完全在超类中定义class ArrayCache extends Cache &#123; _doGet() &#123; // ... &#125; _doSet() &#123; // ... &#125;&#125; class LocalStorageCache extends Cache &#123; _doGet() &#123; // ... &#125; _doSet() &#123; // ... &#125;&#125; // 函数可以通过与超类接口进行交互，在任何 cache 上进行多态操作function compute(cache) &#123; let cached = cache.get(&apos;result&apos;); if (!cached) &#123; let result = // ... cache.set(&apos;result&apos;, result); &#125; // ...&#125; compute(new ArrayCache()); // 通过超类接口使用数组 cachecompute(new LocalStorageCache()); // 通过超类接口使用本地存储的 cache 比语法糖更多JavaScript 类语法通常被认为是语法糖，在很多方面确实如此，但也有真正的差异 – 我们可以用 ES6 classes 做 ES5 做到不到的事情。 静态属性被继承ES5 不允许我们在构造函数之间创建真正的继承。 Object.create 可以创建一个普通对象，但不能创建一个函数对象。我们通过手动复制来伪造静态属性的继承。现在有了 ES6 classes ，我们得到一个子类构造函数和超类构造函数之间的真实原型链接。 12345678// ES5function B() &#123;&#125;B.f = function () &#123;&#125;; function D() &#123;&#125;D.prototype = Object.create(B.prototype); D.f(); // error 12345678// ES6class B &#123; static f() &#123;&#125;&#125; class D extends B &#123;&#125; D.f(); // ok 其他方面还有其他一些不太明显的差异。类构造函数不能被当做函数调用。这样可以防止忘记用 new 来调用构造函数。此外，类构造函数的 prototype 属性无法重新分配。这可能有助于 JavaScript 引擎优化类对象。最后，类方法没有 prototype 属性。这可能是通过消除不必要的对象来节省内存。 通过 Proxies 实现多继承这里有一个使用 proxies 的实验，一个 JavaScript 的新功能，实现多重继承。 JavaScript 的原型链只允许单一的继承。对象可以 委托 给另一个对象。Proxies 给我们一种方法来委托对多个其他对象的属性访问。 12345678910111213141516171819let transmitter = &#123; transmit() &#123;&#125;&#125;; let receiver = &#123; receive() &#123;&#125;&#125;; // 创建一个 proxy 对象，拦截属性访问并发送给每个父对象，// 返回找到的第一个定义的值let inheritsFromMultiple = new Proxy([transmitter, receiver], &#123; get: function(proxyTarget, propertyKey) &#123; const foundParent = proxyTarget.find(parent =&gt; parent[propertyKey] !== undefined); return foundParent &amp;&amp; foundParent[propertyKey]; &#125;&#125;); inheritsFromMultiple.transmit(); // worksinheritsFromMultiple.receive(); // works 我们可以扩展这个和 classes 语法配合使用吗？一个类的 prototype(原型) 可以是一个 proxy(代理) ，它可以发送属性到多个其他原型上访问。JavaScript社区现在正在努力。你能弄清楚吗？加入讨论并分享您的想法。 用 Class 工厂函数实现的多重继承JavaScript社区一直在尝试的另一种方法是按需生成类，扩展一个变量超类。每个类仍然只有一个父类，但我们可以用有趣的方式把这些父母链在一起。 123456789101112131415161718function makeTransmitterClass(Superclass = Object) &#123; return class Transmitter extends Superclass &#123; transmit() &#123;&#125; &#125;;&#125; function makeReceiverClass(Superclass = Object) &#123; return class Receiver extends Superclass receive() &#123;&#125; &#125;;&#125; class InheritsFromMultiple extends makeTransmitterClass(makeReceiverClass()) &#123;&#125; let inheritsFromMultiple = new InheritsFromMultiple(); inheritsFromMultiple.transmit(); // worksinheritsFromMultiple.receive(); // works 还有其他想象力的方法来使用这些功能吗？现在是时候把你的足迹留在JavaScript世界了。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://walkstreet.github.io/personal-blog/categories/Javascript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://walkstreet.github.io/personal-blog/tags/ES6/"},{"name":"类","slug":"类","permalink":"https://walkstreet.github.io/personal-blog/tags/类/"}]},{"title":"全角半角的字符检测与相互转换","slug":"全角半角字符","date":"2017-06-21T02:37:29.000Z","updated":"2018-02-23T09:47:02.459Z","comments":true,"path":"2017/06/21/全角半角字符/","link":"","permalink":"https://walkstreet.github.io/personal-blog/personal-blog/2017/06/21/全角半角字符/","excerpt":"","text":"全角和半角是什么意思啊？全角：是一种电脑字符，是指一个全角字符占用两个标准字符(或两个半角字符)的位置。全角占两个字节。汉字字符和规定了全角的英文字符及国标GB2312-80中的图形符号和特殊字符都是全角字符。在全角中，字母和数字等与汉字一样占据着等宽的位置。 半角：是指一个字符占用一个标准的字符位置。半角占一个字节。半角就是 ASCII 方式的字符，在没有汉字输入法起作用的时候，输入的字母、数字和字符都是半角的。每个半角字符只占用一字节的空间(一字节有8位，共256个编码空间)。汉语、日语、及朝鲜文等象形字语言的字库量远大于256个编码空间，所以改用两个字节来储存。同时，由于中日韩等象形文字的书写习惯，如果统一使用全角字符的话，排列起来也显得整齐。为了排列整齐，英文和其它拉丁文的字符和标点也提供了全角格式。 如何判断在javascript中输入的文字是全角还是半角？1234567891011function issbccase(source) &#123; if(source==&quot;&quot;) &#123; return true; &#125; var reg=/^[\\w\\u4e00-\\u9fa5\\uf900-\\ufa2d]*$/; if(reg.test(source)) &#123; return false; &#125;else &#123; return true; &#125; &#125; 半角全角相互转换的js函数12345678910111213141516171819202122232425262728///全角空格为12288，半角空格为32 ///其他字符半角(33-126)与全角(65281-65374)的对应关系是：均相差65248 //半角转换为全角函数 function ToDBC(txtstring) &#123; var tmp = &quot;&quot;; for(var i=0;i&lt;txtstring.length;i++) &#123; if(txtstring.charCodeAt(i)==32) &#123; tmp= tmp+ String.fromCharCode(12288); &#125; if(txtstring.charCodeAt(i)&lt;127) &#123; tmp=tmp+String.fromCharCode(txtstring.charCodeAt(i)+65248); &#125; &#125; return tmp; &#125;//全角转换为半角函数 function ToCDB(str) &#123; var tmp = &quot;&quot;; for(var i=0;i&lt;str.length;i++) &#123; if(str.charCodeAt(i)&gt;65248&amp;&amp;str.charCodeAt(i)&lt;65375) &#123; tmp += String.fromCharCode(str.charCodeAt(i)-65248); &#125; else &#123; tmp += String.fromCharCode(str.charCodeAt(i)); &#125; &#125; return tmp &#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://walkstreet.github.io/personal-blog/categories/Javascript/"}],"tags":[{"name":"全半角","slug":"全半角","permalink":"https://walkstreet.github.io/personal-blog/tags/全半角/"}]},{"title":"面试的心得(2017-6-19)","slug":"随笔","date":"2017-06-20T03:38:26.000Z","updated":"2018-02-23T09:47:02.459Z","comments":true,"path":"2017/06/20/随笔/","link":"","permalink":"https://walkstreet.github.io/personal-blog/personal-blog/2017/06/20/随笔/","excerpt":"","text":"有幸和一位大神聊过，发现自己有好多地方都略显不足。 函数式编程和面向对象式编程？面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。 将业务逻辑细化，抽象，封装成一个个功能函数，并借助语言自带的高阶函数api，将整个业务流程转化为函数之间的相互调用，这就是函数式编程。 什么是对象？对象就是属性和方法的集合，所有的数据类型都是对象，他们都有自己的默认支持的方法。 Array.prototype.slice.call查看jQuery的源代码，会看到类似： slice = Array.prototype.slice, 或 array = Array.prototype.slice.call( array, 0 ); 的代码。 干嘛用的呢？ 作用就是：将类似数组的对象转换为真实的数组。 真实数组具有slice方法，可以对数组进行浅复制（不影响原数组），返回的依然是数组。 类似数组虽然有length属性，可以使用for循环遍历，却不能直接使用slice方法，会报错！但是通过Array.prototype.slice.call则不会报错，本身（类似数组）被从头到尾slice复制了一遍——变成了真实数组！ 上一集demo中函数内部的arguments是应该都熟知的类似数组，于是： Array.prototype.slice.call(arguments) bind函数，改变上下文12345678910111213var OOO = &#123; color: &quot;#cd0000&quot;, element: $(&quot;#text&quot;), events: function() &#123; $(&quot;input[type=&apos;button&apos;]&quot;).addEventListener(&quot;click&quot;, function(e) &#123; this.element.style.color = this.color; &#125;.bind(this)); return this; &#125;, init: function() &#123; this.events(); &#125;&#125;; 为IE6~8自定义bind方法12345678910if (!function() &#123;&#125;.bind) &#123; Function.prototype.bind = function(context) &#123; var self = this , args = Array.prototype.slice.call(arguments); return function() &#123; return self.apply(context, args.slice(1)); &#125; &#125;;&#125; 很多原理性的知识点无法从碎片连成面看来在接下去的时间里，必须再好好学习基础知识。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://walkstreet.github.io/personal-blog/categories/随笔/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://walkstreet.github.io/personal-blog/tags/面试/"}]},{"title":"array数组操作","slug":"array数组操作","date":"2017-06-19T07:17:46.000Z","updated":"2018-02-23T10:05:20.000Z","comments":true,"path":"2017/06/19/array数组操作/","link":"","permalink":"https://walkstreet.github.io/personal-blog/personal-blog/2017/06/19/array数组操作/","excerpt":"数组常用方法数组的创建12345var arrayObj = new Array(); //创建一个数组var arrayObj = new Array([size]); //创建一个数组并指定长度，注意不是上限，是长度var arrayObj = new Array([element0[, element1[, ...[, elementN]]]]); //创建一个数组并赋值 要说明的是，虽然第二种方法创建数组指定了长度，但实际上所有情况下数组都是变长的，也就是说即使指定了长度为5，仍然可以将元素存储在规定长度以外的，注意：这时长度会随之改变 数组的元素的访问12var testGetArrValue = arrayObj[1]; //获取数组的元素值arrayObj[1] = &quot;这是新值&quot;; //给数组元素赋予新的值 数组元素的添加12345678arrayObj.push([item1 [item2 [. . . [itemN ]]]]);// 将一个或多个新元素添加到数组结尾，并返回数组新长度arrayObj.unshift([item1 [item2 [. . . [itemN ]]]]);// 将一个或多个新元素添加到数组开始，数组中的元素自动后移，返回数组新长度arrayObj.splice(insertPos,0,[item1[, item2[, . . . [,itemN]]]]);//将一个或多个新元素插入到数组的指定位置，插入位置的元素自动后移，返回&quot;&quot;。","text":"数组常用方法数组的创建12345var arrayObj = new Array(); //创建一个数组var arrayObj = new Array([size]); //创建一个数组并指定长度，注意不是上限，是长度var arrayObj = new Array([element0[, element1[, ...[, elementN]]]]); //创建一个数组并赋值 要说明的是，虽然第二种方法创建数组指定了长度，但实际上所有情况下数组都是变长的，也就是说即使指定了长度为5，仍然可以将元素存储在规定长度以外的，注意：这时长度会随之改变 数组的元素的访问12var testGetArrValue = arrayObj[1]; //获取数组的元素值arrayObj[1] = &quot;这是新值&quot;; //给数组元素赋予新的值 数组元素的添加12345678arrayObj.push([item1 [item2 [. . . [itemN ]]]]);// 将一个或多个新元素添加到数组结尾，并返回数组新长度arrayObj.unshift([item1 [item2 [. . . [itemN ]]]]);// 将一个或多个新元素添加到数组开始，数组中的元素自动后移，返回数组新长度arrayObj.splice(insertPos,0,[item1[, item2[, . . . [,itemN]]]]);//将一个或多个新元素插入到数组的指定位置，插入位置的元素自动后移，返回&quot;&quot;。 数组元素的删除123456arrayObj.pop(); //移除最后一个元素并返回该元素值arrayObj.shift(); //移除最前一个元素并返回该元素值，数组中元素自动前移arrayObj.splice(deletePos,deleteCount);//删除从指定位置deletePos开始的指定数量deleteCount的元素，数组形式返回所移除的元素 数组的截取和合并12345arrayObj.slice(start, [end]);//以数组的形式返回数组的一部分，注意不包括 end 对应的元素，如果省略 end 将复制 start 之后的所有元素arrayObj.concat([item1[, item2[, . . . [,itemN]]]]);//将多个数组（也可以是字符串，或者是数组和字符串的混合）连接为一个数组，返回连接好的新的数组 数组的拷贝12arrayObj.slice(0); //返回数组的拷贝数组，注意是一个新的数组，不是指向arrayObj.concat(); //返回数组的拷贝数组，注意是一个新的数组，不是指向 数组元素的排序12arrayObj.reverse(); //反转元素（最前的排到最后、最后的排到最前），返回数组地址arrayObj.sort(); //对数组元素排序，返回数组地址 数组元素的字符串化join()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串： 123arrayObj.join(separator); //返回字符串，这个字符串将数组的每一个元素值连接在一起，中间用 separator 隔开。var arr = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, 1, 2, 3];arr.join(&apos;-&apos;); // &apos;A-B-C-1-2-3&apos; 如果Array的元素不是字符串，将自动转换为字符串后再连接。 valueOf: 与String类似，Array也可以通过indexOf()来搜索一个指定的元素的位置： 1234var arr = [10, 20, &apos;30&apos;, &apos;xyz&apos;];arr.indexOf(10); // 元素10的索引为0arr.indexOf(30); // 元素30没有找到，返回-1arr.indexOf(&apos;30&apos;); // 元素&apos;30&apos;的索引为2 toLocaleString 、toString：可以看作是join的特殊用法，不常用;toLocaleString(): 方法可根据本地时间把 Date 对象转换为字符串，并返回结果。toString:把数组转换为字符串，并返回结果。lastIndexOf：返回在数组中搜索到的与给定参数相等的元素的最后（最大）索引。toSource(): 返回一个字符串,代表该数组的源代码.该特性是非标准的，请尽量不要在生产环境中使用它！ Array.prototype.toSource() 求两个数组的交集、差集和并集？12345678910111213// 求交集（a ∩ b）两种方法let intersection = a.filter(v =&gt; b.includes(v))let intersectionSet = Array.from(new Set([...a].filter(x =&gt; b.includes(x))))// 求差集（a - b）两种方法let difference = a.concat(b).filter(v =&gt; !a.includes(v) || !b.includes(v))let differenceSet = Array.from(new Set([...a].filter(x =&gt; !b.includes(x))))// 求并集（a u b)两种方法let union ＝ a.concat(b).filter(function(item, index, array) &#123; return array.indexOf(item) === index;&#125;)let unionSet = Array.from(new Set([...a, ...b])) 数组对象的3个属性length属性Length属性表示数组的长度，即其中元素的个数。因为数组的索引总是由0开始，所以一个数组的上下限分别是：0和length-1。和其他大多数语言不同的是，JavaScript数组的length属性是可变的，这一点需要特别注意。当length属性被设置得更大时，整个数组的状态事实上不会发生变化，仅仅是length属性变大；当length属性被设置得比原来小时，则原先数组中索引大于或等于length的元素的值全部被丢失。下面是演示改变length属性的例子： 123456789101112var arr=[12,23,5,3,25,98,76,54,56,76];//定义了一个包含10个数字的数组alert(arr.length); //显示数组的长度10arr.length=12; //增大数组的长度alert(arr.length); //显示数组的长度已经变为12alert(arr[8]); //显示第9个元素的值，为56arr.length=5; //将数组的长度减少到5，索引等于或超过5的元素被丢弃alert(arr[8]); //显示第9个元素已经变为&quot;undefined&quot;arr.length=10; //将数组长度恢复为10alert(arr[8]); //虽然长度被恢复为10，但第9个元素却无法收回，显示&quot;undefined&quot; 由上面的代码我们可以清楚的看到length属性的性质。但length对象不仅可以显式的设置，它也有可能被隐式修改。JavaScript中可以使用一个未声明过的变量，同样，也可以使用一个未定义的数组元素（指索引超过或等于length的元素），这时，length属性的值将被设置为所使用元素索引的值加1。例如下面的代码： 123456789var arr=[12,23,5,3,25,98,76,54,56,76];console.log(arr.length); // 10arr[15] = 34;console.log(arr.length); //16console.log(arr[10]); //undefineconsole.log(arr.toString())//12,23,5,3,25,98,76,54,56,76,,,,,,34 代码中同样是先定义了一个包含10个数字的数组，通过alert语句可以看出其长度为10。随后使用了索引为15的元素，将其赋值为15，即 arr[15]=34，这时再用alert语句输出数组的长度，得到的是16。无论如何，对于习惯于强类型编程的开发人员来说，这是一个很令人惊讶的特性。事实上，使用new Array()形式创建的数组，其初始长度就是为0，正是对其中未定义元素的操作，才使数组的长度发生变化。大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界。由上面的介绍可以看到，length属性是如此的神奇，利用它可以方便的增加或者减少数组的容量。因此对length属性的深入了解，有助于在开发过程中灵活运用。 prototype 属性返回对象类型原型的引用。prototype 属性是 object 共有的。 objectName.prototype:objectName 参数是object对象的名称。说明：用 prototype 属性提供对象的类的一组基本功能。 对象的新实例“继承”赋予该对象原型的操作。对于数组对象，以以下例子说明prototype 属性的用途。 给数组对象添加返回数组中最大元素值的方法。要完成这一点，声明一个函数，将它加入 Array.prototype， 并使用它。 1234567891011121314function array_max() &#123; var i, max = this[0]; for (i = 1; i &lt; this.length; i++) &#123; if (max &lt; this[i]) max = this[i]; &#125; return max;&#125;Array.prototype.max = array_max;var x = new Array(1, 2, 3, 4, 5, 6);var y = x.max(); 该代码执行后，y 保存数组 x 中的最大值，即：6。 constructor 属性表示创建对象的函数。object.constructor //object是对象或函数的名称。 说明：constructor 属性是所有具有 prototype 的对象的成员。它们包括除 Global 和 Math 对象以外的所有 JScript 固有对象。constructor 属性保存了对构造特定对象实例的函数的引用。 12345678910x = new String(&quot;Hi&quot;);if (x.constructor == String) // 进行处理（条件为真）。function MyFunc &#123; // 函数体。&#125;y = new MyFunc;if (y.constructor == MyFunc) // 进行处理（条件为真）。y = new Array(); 判断是否为数组js因为设计上的某些缺陷，导致在对于Array的判断，也是颇费周折的。typeof 操作符:对于Function， String， Number ，Undefined 等几种类型的对象来说，他完全可以胜任，但是为Array时,难免会让人失望： 12var arr=new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;);alert(typeof(arr)); // Object instanceof 操作符: 运算符会返回一个 Boolean 值，指出对象是否是特定类的一个实例。 12var arrayStr=new Array(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;);alert(arrayStr instanceof Array); //true 虽然此时能够完好的工作，但，事实上在多个frame中穿梭就会产生大问题了。所以~~~ 1234567var iframe = document.createElement(&apos;iframe&apos;); document.body.appendChild(iframe); xArray = window.frames[window.frames.length-1].Array; var arr = new xArray(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;);//这个写法IE大哥下是不支持的，FF下才有alert(arr instanceof Array); // falsealert(arr.constructor === Array); // false ECMA-262中规范定义了Object.prototype.toString的行为：首先，取得对象的一个内部属性[[Class]]，然后依据这个属性，返回一个类似于”[object Array]”的字符串作为结果（看过ECMA标准的应该都知道，[[]]用来表示语言内部用到的、外部不可直接访问的属性，称为“内部属性”）。利用这个方法，再配合call，我们可以取得任何对象的内部属性[[Class]]，然后把类型检测转化为字符串比较，以达到我们的目的。于是利用这点，就有了下面这种方法： 123function isArray(obj) &#123; return Object.prototype.toString.call(obj) === &apos;[object Array]&apos;; &#125; call改变toString的this引用为待检测的对象，返回此对象的字符串表示，然后对比此字符串是否是’[object Array]’，以判断其是否是Array的实例。也许你要问了，为什么不直接o.toString()？嗯，虽然Array继承自Object，也会有toString方法，但是这个方法有可能会被改写而达不到我们的要求，而Object.prototype则是老虎的屁股，很少有人敢去碰它的，所以能一定程度保证其“纯洁性”：）。这也是Array.isArray()方法的兼容旧环境（Polyfill）。 如此很好的解决了跨frame对象构建的问题，经过测试，各大浏览器兼容性也很好，可以放心使用。很多框架，比如jQuery、Base2等等，都计划借鉴此方法以实现某些特殊的，比如数组、正则表达式等对象的类型判定！当然也可以写成如下这样： 123function isArray2 (v)&#123; return toString.apply(v) === &apos;[object Array]&apos;;&#125; 要注意的是：toString方法极有可能被重写，所以需要使用的时候，可以直接使用Object.prototype.toString()方法。 Array.isArray()方法用来判断某个值是否为数组。如果是，则返回 true，否则返回 false。 1234567891011121314151617// 下面的函数调用都返回 trueArray.isArray([]);Array.isArray([1]);Array.isArray(new Array());// 鲜为人知的事实：其实 Array.prototype 也是一个数组。Array.isArray(Array.prototype);// 下面的函数调用都返回 falseArray.isArray();Array.isArray(&#123;&#125;);Array.isArray(null);Array.isArray(undefined);Array.isArray(17);Array.isArray(&apos;Array&apos;);Array.isArray(true);Array.isArray(false);Array.isArray(&#123; __proto__: Array.prototype &#125;); 数组迭代过程filter()方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。语法：arr.filter(callback[, thisArg])如果为 filter 提供一个 thisArg 参数，则它会被作为 callback 被调用时的 this 值。否则，callback 的 this 值在非严格模式下将是全局对象，严格模式下为 undefined。 filter 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或 等价于 true 的值 的元素创建一个新数组。callback 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中。 示例：筛选排除掉所有的小值 12345function isBigEnough(element) &#123; return element &gt;= 10;&#125;var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);// filtered is [12, 130, 44] forEach()方法让数组的每一项都执行一次给定的函数。语法: array.forEach(callback[, thisArg]) forEach 方法按升序为数组中含有效值的每一项执行一次callback 函数，那些已删除（使用delete方法等情况）或者从未赋值的项将被跳过（但不包括哪些值为 undefined 的项）。 forEach 遍历的范围在第一次调用 callback 前就会确定。调用forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。已删除的项不会被遍历到。 注意： 没有办法中止 forEach 循环。如果要中止，可使用 Array.every 或 Array.some。见下面的例子。 示例1:打印出数组的内容 12345678function logArrayElements(element, index, array) &#123; console.log(&quot;a[&quot; + index + &quot;] = &quot; + element);&#125;[2, 5, 9].forEach(logArrayElements);// logs:// a[0] = 2// a[1] = 5// a[2] = 9 示例2:一个可以克隆对象的函数使用下面的代码可以复制一个给定的对象,虽然有很多不同的复制对象的方法.不过下面介绍的这种方法使用了Array.prototype.forEach和其他一些ECMAScript 5中的Object.*函数. 1234567891011function copy(o)&#123; var copy = Object.create( Object.getPrototypeOf(o) ); var propNames = Object.getOwnPropertyNames(o); propNames.forEach(function(name)&#123; var desc = Object.getOwnPropertyDescriptor(o, name); Object.defineProperty(copy, name, desc); &#125;); return copy;&#125;var o1 = &#123;a:1, b:2&#125;;var o2 = copy(o1); // o2 looks like o1 now every()方法测试数组的所有元素是否都通过了指定函数的测试。语法:arr.every(callback[, thisArg]) every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 falsy（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。callback 只会为那些已经被赋值的索引调用。不会为那些被删除或从来没被赋值的索引调用。callback 被调用时传入三个参数：元素值，元素的索引，原数组。 every 不会改变原数组。 实例：检测所有数组元素的大小 12345678//检测数组中的所有元素是否都大于 10function isBigEnough(element, index, array) &#123; return (element &gt;= 10);&#125;var passed = [12, 5, 8, 130, 44].every(isBigEnough);// passed is falsepassed = [12, 54, 18, 130, 44].every(isBigEnough);// passed is true map()方法返回一个由原数组中的每个元素调用一个指定方法后的返回值组成的新数组。语法: array.map(callback[, thisArg]) map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值组合起来形成一个新数组。 callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。map 不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）。 实例一：求数组中每个元素的平方根 1234//在一个 String 上使用 map 方法获取字符串中每个字符所对应的 ASCII 码组成的数组：var map = Array.prototype.mapvar a = map.call(&quot;Hello World&quot;, function(x) &#123; return x.charCodeAt(0); &#125;)// a的值为[72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100] 通常情况下，map 方法中的 callback 函数只需要接受一个参数，就是正在被遍历的数组元素本身。但这并不意味着 map 只给 callback 传了一个参数。这个思维惯性可能会让我们犯一个很容易犯的错误。比如下面的语句返回什么呢: 123[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt);// 你可能觉的会是[1, 2, 3]// 但实际的结果是 [1, NaN, NaN] 通常使用parseInt时,只需要传递一个参数.但实际上,parseInt可以有两个参数.第二个参数是进制数.可以通过语句”alert(parseInt.length)===2”来验证.map方法在调用callback函数时,会给它传递三个参数:当前正在遍历的元素, 元素索引, 原数组本身.第三个参数parseInt会忽视, 但第二个参数不会,也就是说,parseInt把传过来的索引值当成进制数来使用.从而返回了NaN。 因此此时应该使用如下的用户函数returnInt： 12345function returnInt(element)&#123; return parseInt(element,10);&#125;[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(returnInt);// 返回[1,2,3] some()方法测试数组中的某些元素是否通过了指定函数的测试。语法: arr.some(callback[, thisArg]) 描述:some 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。如果找到了这样一个值，some 将会立即返回 true。否则，some 返回 false。callback 只会在那些”有值“的索引上被调用，不会在那些被删除或从来未被赋值的索引上调用。 示例：测试数组元素的值 12345678//检测在数组中是否有元素大于 10。function isBigEnough(element, index, array) &#123; return (element &gt;= 10);&#125;var passed = [2, 5, 8, 1, 4].some(isBigEnough);// passed is falsepassed = [12, 5, 8, 1, 4].some(isBigEnough);// passed is true reduce()接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。语法: arr.reduce(callback,[initialValue])callback:执行数组中每个值的函数，包含四个参数 previousValue:上一次调用回调返回的值，或者是提供的初始值（initialValue） currentValue 数组中当前被处理的元素 index 当前元素在数组中的索引 array 调用 reduce 的数组initialValue: 作为第一次调用 callback 的第一个参数。 描述:reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。回调函数第一次执行时，previousValue 和 currentValue 可以是一个值，如果 initialValue 在调用 reduce 时被提供，那么第一个 previousValue 等于 initialValue ，并且currentValue 等于数组中的第一个值；如果initialValue 未被提供，那么previousValue 等于数组中的第一个值，currentValue等于数组中的第二个值。如果数组为空并且没有提供initialValue， 会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。示例1：将数组所有项相加 1234var total = [0, 1, 2, 3].reduce(function(a, b) &#123; return a + b;&#125;);// total == 6 示例2: 数组扁平化 1234var flattened = [[0, 1], [2, 3], [4, 5]].reduce(function(a, b) &#123; return a.concat(b);&#125;);// flattened is [0, 1, 2, 3, 4, 5] 示例2: 统计一个数组中有多少个不重复的单词 不使用reduce时的写法 12345678910var arr = [&quot;apple&quot;,&quot;orange&quot;,&quot;apple&quot;,&quot;orange&quot;,&quot;pear&quot;,&quot;orange&quot;];function getWordCnt()&#123; var obj = &#123;&#125;; for(var i= 0, l = arr.length; i&lt; l; i++)&#123; var item = arr[i]; obj[item] = (obj[item] +1 ) || 1; &#125; return obj;&#125;console.log(getWordCnt()); 使用reduce()后的写法： 12345678var arr = [&quot;apple&quot;,&quot;orange&quot;,&quot;apple&quot;,&quot;orange&quot;,&quot;pear&quot;,&quot;orange&quot;];function getWordCnt()&#123; return arr.reduce(function(prev,next)&#123; prev[next] = (prev[next] + 1) || 1; return prev; &#125;,&#123;&#125;);&#125;console.log(getWordCnt()); 这其中一个需要注意的点在于，initialValue提供与否对prev和next的影响； 12345678910111213141516171819202122/* 二者的区别，在console中运行一下即可知晓*/var arr = [&quot;apple&quot;,&quot;orange&quot;,&apos;pear&apos;,&apos;jade&apos;];function noPassValue()&#123; return arr.reduce(function(prev,next)&#123; console.log(&quot;prev:&quot;,prev); console.log(&quot;next:&quot;,next); //console.info(&apos;prev type:&apos;+ typeof(prev)); //prev type:string return prev + &quot; &quot; +next; &#125;);&#125;function passValue()&#123; return arr.reduce(function(prev,next)&#123; console.log(&quot;prev:&quot;,prev); console.log(&quot;next:&quot;,next); prev[next] = 1; //console.info(&apos;prev type:&apos;+ typeof(prev)); // object return prev; &#125;,&#123;&#125;);&#125;console.log(&quot;No Additional parameter:&quot;,noPassValue());console.log(&quot;----------------&quot;);console.log(&quot;With &#123;&#125; as an additional parameter:&quot;,passValue()); 一点总结pop,push,reverse,shift,sort,splice,unshift 会改变原数组join,concat,indexOf,lastIndexOf,slice,toString 不会改变原数组map,filter,some,every,reduce,forEach这些迭代方法不会改变原数组几个注意点：shift,pop会返回那个被删除的元素splice 会返回被删除元素组成的数组，或者为空数组push 会返回新数组长度some 在有true的时候停止every 在有false的时候停止上述的迭代方法可以在最后追加一个参数thisArg,它是执行 callback 时的 this 值。JavaScript的数据类型分为：值类型和引用类型(地址值)；而常见的引用类型有Object和Array／数组的存储模型中，如果是诸如Number,String之类的类型数据会被直接压入栈中，而引用类型只会压入对该值的一个索引（即C中所说的保存了数据的指针）。这些数据时储存在堆中的某块区间中，堆栈并不是独立的，栈中也可以在堆中存放。在使用Array的进行赋值操作的时候，也当注意是否要进行深度拷贝复制(可借助arr.slice(0))，以免造成对自身污染。对于Js数据，其实内容还是还有很多需要学习的，比如ArrayBuffer等。根据学以致用的原则，这些等到需要的时候再去学吧。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://walkstreet.github.io/personal-blog/categories/Javascript/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://walkstreet.github.io/personal-blog/tags/Array/"}]},{"title":"vue axios全攻略","slug":"axios-vue官方推荐的请求客户端","date":"2017-06-15T02:00:22.000Z","updated":"2018-02-23T09:47:02.456Z","comments":true,"path":"2017/06/15/axios-vue官方推荐的请求客户端/","link":"","permalink":"https://walkstreet.github.io/personal-blog/personal-blog/2017/06/15/axios-vue官方推荐的请求客户端/","excerpt":"不再继续维护vue-resource，并推荐大家使用 axios。此文是官方文档翻译。 axios 简介axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征： 从浏览器中创建 XMLHttpRequest 从 node.js 发出 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防止 CSRF/XSRF 浏览器兼容 引入方式123456$ npm install axios$ cnpm install axios //taobao源$ bower install axios// 或者使用cdn：&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;","text":"不再继续维护vue-resource，并推荐大家使用 axios。此文是官方文档翻译。 axios 简介axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征： 从浏览器中创建 XMLHttpRequest 从 node.js 发出 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防止 CSRF/XSRF 浏览器兼容 引入方式123456$ npm install axios$ cnpm install axios //taobao源$ bower install axios// 或者使用cdn：&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; 举个栗子执行 GET 请求123456789101112131415161718192021// 向具有指定ID的用户发出请求axios.get(&apos;/user?ID=12345&apos;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); // 也可以通过 params 对象传递参数axios.get(&apos;/user&apos;, &#123; params: &#123; ID: 12345 &#125;&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); 执行 POST 请求12345678910axios.post(&apos;/user&apos;, &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos;&#125;).then(function (response) &#123; console.log(response);&#125;).catch(function (error) &#123; console.log(error);&#125;); 执行多个并发请求123456789101112function getUserAccount() &#123; return axios.get(&apos;/user/12345&apos;);&#125; function getUserPermissions() &#123; return axios.get(&apos;/user/12345/permissions&apos;);&#125; axios.all([getUserAccount(), getUserPermissions()]).then(axios.spread(function (acct, perms) &#123; //两个请求现已完成&#125;)); axios API可以通过将相关配置传递给 axios 来进行请求。 axios(config)123456789// 发送一个 POST 请求axios(&#123; method: &apos;post&apos;, url: &apos;/user/12345&apos;, data: &#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;&#125;); axios(url[, config])12// 发送一个 GET 请求 (GET请求是默认请求模式)axios(&apos;/user/12345&apos;); 请求方法别名为了方便起见，已经为所有支持的请求方法提供了别名。 axios.request（config） axios.get（url [，config]） axios.delete（url [，config]） axios.head（url [，config]） axios.post（url [，data [，config]]） axios.put（url [，data [，config]]） axios.patch（url [，data [，config]]） 注意当使用别名方法时，不需要在config中指定url，method和data属性。 并发帮助函数处理并发请求。 axios.all（iterable） axios.spread（callback） 创建实例您可以使用自定义配置创建axios的新实例。 axios.create（[config]） 12345var instance = axios.create(&#123; baseURL: &apos;https://some-domain.com/api/&apos;, timeout: 1000, headers: &#123;&apos;X-Custom-Header&apos;: &apos;foobar&apos;&#125;&#125;); 实例方法可用的实例方法如下所示。 指定的配置将与实例配置合并。 axios＃request（config）axios＃get（url [，config]）axios＃delete（url [，config]）axios＃head（url [，config]）axios＃post（url [，data [，config]]）axios＃put（url [，data [，config]]）axios＃patch（url [，data [，config]]） 请求配置这些是用于发出请求的可用配置选项。 只有url是必需的。 如果未指定方法，请求将默认为GET。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132&#123; // `url`是将用于请求的服务器URL url: &apos;/user&apos;, // `method`是发出请求时使用的请求方法 method: &apos;get&apos;, // 默认 // `baseURL`将被添加到`url`前面，除非`url`是绝对的。 // 可以方便地为 axios 的实例设置`baseURL`，以便将相对 URL 传递给该实例的方法。 baseURL: &apos;https://some-domain.com/api/&apos;, // `transformRequest`允许在请求数据发送到服务器之前对其进行更改 // 这只适用于请求方法&apos;PUT&apos;，&apos;POST&apos;和&apos;PATCH&apos; // 数组中的最后一个函数必须返回一个字符串，一个 ArrayBuffer或一个 Stream transformRequest: [function (data) &#123; // 做任何你想要的数据转换 return data; &#125;], // `transformResponse`允许在 then / catch之前对响应数据进行更改 transformResponse: [function (data) &#123; // Do whatever you want to transform the data return data; &#125;], // `headers`是要发送的自定义 headers headers: &#123;&apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;&#125;, // `params`是要与请求一起发送的URL参数 // 必须是纯对象或URLSearchParams对象 params: &#123; ID: 12345 &#125;, // `paramsSerializer`是一个可选的函数，负责序列化`params` // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123;arrayFormat: &apos;brackets&apos;&#125;) &#125;, // `data`是要作为请求主体发送的数据 // 仅适用于请求方法“PUT”，“POST”和“PATCH” // 当没有设置`transformRequest`时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - Browser only: FormData, File, Blob // - Node only: Stream data: &#123; firstName: &apos;Fred&apos; &#125;, // `timeout`指定请求超时之前的毫秒数。 // 如果请求的时间超过&apos;timeout&apos;，请求将被中止。 timeout: 1000, // `withCredentials`指示是否跨站点访问控制请求 // should be made using credentials withCredentials: false, // default // `adapter&apos;允许自定义处理请求，这使得测试更容易。 // 返回一个promise并提供一个有效的响应（参见[response docs]（＃response-api）） adapter: function (config) &#123; /* ... */ &#125;, // `auth&apos;表示应该使用 HTTP 基本认证，并提供凭据。 // 这将设置一个`Authorization&apos;头，覆盖任何现有的`Authorization&apos;自定义头，使用`headers`设置。 auth: &#123; username: &apos;janedoe&apos;, password: &apos;s00pers3cret&apos; &#125;, // “responseType”表示服务器将响应的数据类型 // 包括 &apos;arraybuffer&apos;, &apos;blob&apos;, &apos;document&apos;, &apos;json&apos;, &apos;text&apos;, &apos;stream&apos; responseType: &apos;json&apos;, // default //`xsrfCookieName`是要用作 xsrf 令牌的值的cookie的名称 xsrfCookieName: &apos;XSRF-TOKEN&apos;, // default // `xsrfHeaderName`是携带xsrf令牌值的http头的名称 xsrfHeaderName: &apos;X-XSRF-TOKEN&apos;, // default // `onUploadProgress`允许处理上传的进度事件 onUploadProgress: function (progressEvent) &#123; // 使用本地 progress 事件做任何你想要做的 &#125;, // `onDownloadProgress`允许处理下载的进度事件 onDownloadProgress: function (progressEvent) &#123; // Do whatever you want with the native progress event &#125;, // `maxContentLength`定义允许的http响应内容的最大大小 maxContentLength: 2000, // `validateStatus`定义是否解析或拒绝给定的promise // HTTP响应状态码。如果`validateStatus`返回`true`（或被设置为`null` promise将被解析;否则，promise将被 // 拒绝。 validateStatus: function (status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // default &#125;, // `maxRedirects`定义在node.js中要遵循的重定向的最大数量。 // 如果设置为0，则不会遵循重定向。 maxRedirects: 5, // 默认 // `httpAgent`和`httpsAgent`用于定义在node.js中分别执行http和https请求时使用的自定义代理。 // 允许配置类似`keepAlive`的选项， // 默认情况下不启用。 httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new https.Agent(&#123; keepAlive: true &#125;), // &apos;proxy&apos;定义代理服务器的主机名和端口 // `auth`表示HTTP Basic auth应该用于连接到代理，并提供credentials。 // 这将设置一个`Proxy-Authorization` header，覆盖任何使用`headers`设置的现有的`Proxy-Authorization` 自定义 headers。 proxy: &#123; host: &apos;127.0.0.1&apos;, port: 9000, auth: : &#123; username: &apos;mikeymike&apos;, password: &apos;rapunz3l&apos; &#125; &#125;, // “cancelToken”指定可用于取消请求的取消令牌 // (see Cancellation section below for details) cancelToken: new CancelToken(function (cancel) &#123; &#125;)&#125; 使用 then 时，您将收到如下响应： 12345678axios.get(&apos;/user/12345&apos;).then(function(response) &#123; console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config);&#125;); 配置默认值您可以指定将应用于每个请求的配置默认值。 全局axios默认值123axios.defaults.baseURL = &apos;https://api.example.com&apos;;axios.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;; 自定义实例默认值1234567//在创建实例时设置配置默认值var instance = axios.create（&#123; baseURL：&apos;https://api.example.com&apos;&#125;）; //在实例创建后改变默认值instance.defaults.headers.common [&apos;Authorization&apos;] = AUTH_TOKEN; 配置优先级顺序配置将与优先顺序合并。 顺序是lib / defaults.js中的库默认值，然后是实例的defaults属性，最后是请求的config参数。 后者将优先于前者。 这里有一个例子。 123456789101112//使用库提供的配置默认值创建实例//此时，超时配置值为`0`，这是库的默认值var instance = axios.create（）; //覆盖库的超时默认值//现在所有请求将在超时前等待2.5秒instance.defaults.timeout = 2500; //覆盖此请求的超时，因为它知道需要很长时间instance.get（&apos;/ longRequest&apos;，&#123; timeout：5000&#125;）; 拦截器你可以截取请求或响应在被 then 或者 catch 处理之前 1234567891011121314151617//添加请求拦截器axios.interceptors.request.use（function（config）&#123; //在发送请求之前做某事 return config;&#125;，function（error）&#123; //请求错误时做些事 return Promise.reject（error）;&#125;）; //添加响应拦截器axios.interceptors.response.use（function（response）&#123; //对响应数据做些事 return response;&#125;，function（error）&#123; //请求错误时做些事 return Promise.reject（error）;&#125;）; 如果你以后可能需要删除拦截器。 12var myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 你可以将拦截器添加到axios的自定义实例。 12var instance = axios.create();instance.interceptors.request.use(function () &#123;/*...*/&#125;); 处理错误1234567891011121314axios.get（&apos;/ user / 12345&apos;） .catch（function（error）&#123; if（error.response）&#123; //请求已发出，但服务器使用状态代码进行响应 //落在2xx的范围之外 console.log（error.response.data）; console.log（error.response.status）; console.log（error.response.headers）; &#125; else &#123; //在设置触发错误的请求时发生了错误 console.log（&apos;Error&apos;，error.message）; &#125;&#125; console.log（error.config）; &#125;）; 您可以使用validateStatus配置选项定义自定义HTTP状态码错误范围。 12345axios.get（&apos;/ user / 12345&apos;，&#123; validateStatus：function（status）&#123; return status &lt; 500; //仅当状态代码大于或等于500时拒绝 &#125;&#125;&#125;） 消除您可以使用取消令牌取消请求。 axios cancel token API基于可取消的promise提议，目前处于阶段1。 您可以使用CancelToken.source工厂创建一个取消令牌，如下所示： 12345678910111213141516var CancelToken = axios.CancelToken;var source = CancelToken.source（）; axios.get(&apos;/user/12345&apos;, &#123; cancelToken: source.token&#125;) .catch(function(thrown) &#123; if (axios.isCancel(thrown)) &#123; console.log(&apos;Request canceled&apos;, thrown.message); &#125; else &#123; // 处理错误 &#125; &#125;); //取消请求（消息参数是可选的）source.cancel（&apos;操作被用户取消。&apos;）; 您还可以通过将执行器函数传递给CancelToken构造函数来创建取消令牌： 123456789101112var CancelToken = axios.CancelToken;var cancel; axios.get（&apos;/ user / 12345&apos;，&#123; cancelToken：new CancelToken（function executor（c）&#123; //一个执行器函数接收一个取消函数作为参数 cancel = c; &#125;）&#125;）; // 取消请求clear(); 注意：您可以使用相同的取消令牌取消几个请求。 使用application / x-www-form-urlencoded格式默认情况下，axios将JavaScript对象序列化为JSON。 要以应用程序/ x-www-form-urlencoded格式发送数据，您可以使用以下选项之一。 浏览器在浏览器中，您可以使用URLSearchParams API，如下所示： 1234var params = new URLSearchParams();params.append(&apos;param1&apos;, &apos;value1&apos;);params.append(&apos;param2&apos;, &apos;value2&apos;);axios.post(&apos;/foo&apos;, params); 请注意，所有浏览器都不支持URLSearchParams，但是有一个polyfill可用（确保polyfill全局环境）。 或者，您可以使用qs库对数据进行编码： 12var qs = require(&apos;qs&apos;);axios.post(&apos;/foo&apos;, qs.stringify(&#123; &apos;bar&apos;: 123 &#125;); Node.js在node.js中，可以使用querystring模块，如下所示： 12var querystring = require(&apos;querystring&apos;);axios.post(&apos;http://something.com/&apos;, querystring.stringify(&#123; foo: &apos;bar&apos; &#125;); 你也可以使用qs库。 Promiseaxios 依赖本机要支持ES6 Promise实现。 如果您的环境不支持ES6 Promises，您可以使用polyfill。 TypeScriptaxios包括TypeScript定义。 12import axios from &apos;axios&apos;;axios.get(&apos;/user?ID=12345&apos;); axios在很大程度上受到Angular提供的$http服务的启发。 最终，axios努力提供一个在Angular外使用的独立的$http-like服务。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://walkstreet.github.io/personal-blog/categories/Javascript/"}],"tags":[{"name":"Vue2.0","slug":"Vue2-0","permalink":"https://walkstreet.github.io/personal-blog/tags/Vue2-0/"},{"name":"axios","slug":"axios","permalink":"https://walkstreet.github.io/personal-blog/tags/axios/"}]},{"title":"ES6的Arrow函数","slug":"ES6的Arrow函数","date":"2017-06-14T07:31:07.000Z","updated":"2018-02-23T09:47:02.455Z","comments":true,"path":"2017/06/14/ES6的Arrow函数/","link":"","permalink":"https://walkstreet.github.io/personal-blog/personal-blog/2017/06/14/ES6的Arrow函数/","excerpt":"语法 具有一个参数的简单函数 12var single = a =&gt; asingle(&apos;hello, world!&apos;) // &apos;hello, world!&apos; 没有参数的需要用在箭头前加上小括号 123var log = () =&gt; &#123; alert(&apos;no param)&#125; 多个参数需要用到小括号，参数间逗号间隔，例如两个数字相加 12var add = (a, b) =&gt; a + badd(3, 8) //11 函数体多条语句需要用到大括号 1234567var add = (a, b) =&gt; &#123; if (typeof a == &apos;number&apos; &amp;&amp; typeof b == &apos;number&apos;) &#123; return a + b &#125; else &#123; return 0 &#125;&#125;","text":"语法 具有一个参数的简单函数 12var single = a =&gt; asingle(&apos;hello, world!&apos;) // &apos;hello, world!&apos; 没有参数的需要用在箭头前加上小括号 123var log = () =&gt; &#123; alert(&apos;no param)&#125; 多个参数需要用到小括号，参数间逗号间隔，例如两个数字相加 12var add = (a, b) =&gt; a + badd(3, 8) //11 函数体多条语句需要用到大括号 1234567var add = (a, b) =&gt; &#123; if (typeof a == &apos;number&apos; &amp;&amp; typeof b == &apos;number&apos;) &#123; return a + b &#125; else &#123; return 0 &#125;&#125; 返回对象时需要用小括号包起来，因为大括号被占用解释为代码块了 1234567var getHash = arr =&gt; &#123; // ... return (&#123; name: &apos;Jack&apos;, age: 33 &#125;)&#125; 直接作为事件handler 123document.addEventListener(&apos;click&apos;, ev =&gt; &#123; console.log(ev)&#125;) 作为数组排序回调 12345678var arr = [1, 9 , 2, 4, 3, 8].sort((a, b) =&gt; &#123; if (a - b &gt; 0 ) &#123; return 1 &#125; else &#123; return -1 &#125;&#125;)arr // [1, 2, 3, 4, 8, 9] 注意点 typeof运算符和普通的function一样 12var func = a =&gt; aconsole.log(typeof func); // &quot;function&quot; instanceof也返回true，表明也是Function的实例 1console.log(func instanceof Function); // true this固定，不再善变 12345678910111213obj = &#123; data: [&apos;John Backus&apos;, &apos;John Hopcroft&apos;], init: function() &#123; document.onclick = ev =&gt; &#123; alert(this.data) // [&apos;John Backus&apos;, &apos;John Hopcroft&apos;] &#125; // 非箭头函数 // document.onclick = function(ev) &#123; // alert(this.data) // undefined // &#125; &#125;&#125;obj.init() 这个很有用，再不用写me，self，_this了，或者bind。 箭头函数不能用new 12345var Person = (name, age) =&gt; &#123; this.name = name this.age = age&#125;var p = new Func(&apos;John&apos;, 33) // error 不能使用argument 123var func = () =&gt; &#123; console.log(arguments)&#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://walkstreet.github.io/personal-blog/categories/Javascript/"}],"tags":[{"name":"Arrow","slug":"Arrow","permalink":"https://walkstreet.github.io/personal-blog/tags/Arrow/"},{"name":"ES6","slug":"ES6","permalink":"https://walkstreet.github.io/personal-blog/tags/ES6/"}]},{"title":"ES7的Async/Await","slug":"ES7的async和await","date":"2017-06-14T07:00:37.000Z","updated":"2018-02-23T09:47:02.455Z","comments":true,"path":"2017/06/14/ES7的async和await/","link":"","permalink":"https://walkstreet.github.io/personal-blog/personal-blog/2017/06/14/ES7的async和await/","excerpt":"例子Async/Await应该是目前最简单的异步方案了，首先来看个例子。 这里我们要实现一个暂停功能，输入N毫秒，则停顿N毫秒后才继续往下执行。 12345678910111213141516var sleep = function (time) &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve(); &#125;, time); &#125;)&#125;;var start = async function () &#123; // 在这里使用起来就像同步代码那样直观 console.log(&apos;start&apos;); await sleep(3000); console.log(&apos;end&apos;);&#125;;start(); 控制台先输出start，稍等3秒后，输出了end。 基本规则 async 表示这是一个async函数，await只能用在这个函数里面。 await 表示在这里等待promise返回结果了，再继续执行。 await 后面跟着的应该是一个promise对象（当然，其他返回值也没关系，只是会立即执行，不过那样就没有意义了…）","text":"例子Async/Await应该是目前最简单的异步方案了，首先来看个例子。 这里我们要实现一个暂停功能，输入N毫秒，则停顿N毫秒后才继续往下执行。 12345678910111213141516var sleep = function (time) &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve(); &#125;, time); &#125;)&#125;;var start = async function () &#123; // 在这里使用起来就像同步代码那样直观 console.log(&apos;start&apos;); await sleep(3000); console.log(&apos;end&apos;);&#125;;start(); 控制台先输出start，稍等3秒后，输出了end。 基本规则 async 表示这是一个async函数，await只能用在这个函数里面。 await 表示在这里等待promise返回结果了，再继续执行。 await 后面跟着的应该是一个promise对象（当然，其他返回值也没关系，只是会立即执行，不过那样就没有意义了…） 获得返回值await等待的虽然是promise对象，但不必写.then(..)，直接可以得到返回值。 12345678910111213var sleep = function (time) &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; // 返回 ‘ok’ resolve(&apos;ok&apos;); &#125;, time); &#125;)&#125;;var start = async function () &#123; let result = await sleep(3000); console.log(result); // 收到 ‘ok’&#125;; 捕捉错误既然.then(..)不用写了，那么.catch(..)也不用写，可以直接用标准的try catch语法捕捉错误。 1234567891011121314151617181920var sleep = function (time) &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; // 模拟出错了，返回 ‘error’ reject(&apos;error&apos;); &#125;, time); &#125;)&#125;;var start = async function () &#123; try &#123; console.log(&apos;start&apos;); await sleep(3000); // 这里得到了一个返回错误 // 所以以下代码不会被执行了 console.log(&apos;end&apos;); &#125; catch (err) &#123; console.log(err); // 这里捕捉到错误 `error` &#125;&#125;; 循环多个awaitawait看起来就像是同步代码，所以可以理所当然的写在for循环里，不必担心以往需要闭包才能解决的问题。 12345678..省略以上代码var start = async function () &#123; for (var i = 1; i &lt;= 10; i++) &#123; console.log(`当前是第$&#123;i&#125;次等待..`); await sleep(1000); &#125;&#125;; 值得注意的是，await必须在async函数的上下文中的。 123456789101112131415..省略以上代码let 一到十 = [1,2,3,4,5,6,7,8,9,10];// 错误示范一到十.forEach(function (v) &#123; console.log(`当前是第$&#123;v&#125;次等待..`); await sleep(1000); // 错误!! await只能在async函数中运行&#125;);// 正确示范for(var v of 一到十) &#123; console.log(`当前是第$&#123;v&#125;次等待..`); await sleep(1000); // 正确, for循环的上下文还在async函数中&#125; 实际应用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import fs from &apos;fs&apos;;import path from &apos;path&apos;;import request from &apos;request&apos;;var movieDir = __dirname + &apos;/movies&apos;, exts = [&apos;.mkv&apos;, &apos;.avi&apos;, &apos;.mp4&apos;, &apos;.rm&apos;, &apos;.rmvb&apos;, &apos;.wmv&apos;];// 读取文件列表var readFiles = function () &#123; return new Promise(function (resolve, reject) &#123; fs.readdir(movieDir, function (err, files) &#123; resolve(files.filter((v) =&gt; exts.includes(path.parse(v).ext))); &#125;); &#125;);&#125;;// 获取海报var getPoster = function (movieName) &#123; let url = `https://api.douban.com/v2/movie/search?q=$&#123;encodeURI(movieName)&#125;`; return new Promise(function (resolve, reject) &#123; request(&#123;url: url, json: true&#125;, function (error, response, body) &#123; if (error) return reject(error); resolve(body.subjects[0].images.large); &#125;) &#125;);&#125;;// 保存海报var savePoster = function (movieName, url) &#123; request.get(url).pipe(fs.createWriteStream(path.join(movieDir, movieName + &apos;.jpg&apos;)));&#125;;(async () =&gt; &#123; let files = await readFiles(); // await只能使用在原生语法 for (var file of files) &#123; let name = path.parse(file).name; console.log(`正在获取【$&#123;name&#125;】的海报`); savePoster(name, await getPoster(name)); &#125; console.log(&apos;=== 获取海报完成 ===&apos;);&#125;)();","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://walkstreet.github.io/personal-blog/categories/Javascript/"}],"tags":[{"name":"ES7","slug":"ES7","permalink":"https://walkstreet.github.io/personal-blog/tags/ES7/"},{"name":"Async/Await","slug":"Async-Await","permalink":"https://walkstreet.github.io/personal-blog/tags/Async-Await/"}]},{"title":"Promise详解","slug":"promise","date":"2017-06-06T02:15:19.000Z","updated":"2018-02-23T09:47:02.458Z","comments":true,"path":"2017/06/06/promise/","link":"","permalink":"https://walkstreet.github.io/personal-blog/personal-blog/2017/06/06/promise/","excerpt":"Promise在ES2015（ES6）正式规范中，这篇文章详解Promise基本概念和使用方法。 PromisePromise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。这么说用Promise new出来的对象肯定就有then、catch方法。 具体可以使用console.log(Promise);查看 接下来，new一个Promise的构造函数看下。1234567var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log(&apos;执行完成&apos;); resolve(&apos;随便什么数据&apos;); &#125;, 2000);&#125;); Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected。不过在我们开始阶段可以先这么理解，后面再细究概念。 在上面的代码中，我们执行了一个异步操作，也就是setTimeout，2秒后，输出“执行完成”，并且调用resolve方法。 运行代码，会在2秒后输出“执行完成”。注意！我只是new了一个对象，并没有调用它，我们传进去的函数就已经执行了，这是需要注意的一个细节。所以我们用Promise的时候一般是包在一个函数中，在需要的时候去运行这个函数，如：","text":"Promise在ES2015（ES6）正式规范中，这篇文章详解Promise基本概念和使用方法。 PromisePromise是一个构造函数，自己身上有all、reject、resolve这几个眼熟的方法，原型上有then、catch等同样很眼熟的方法。这么说用Promise new出来的对象肯定就有then、catch方法。 具体可以使用console.log(Promise);查看 接下来，new一个Promise的构造函数看下。1234567var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log(&apos;执行完成&apos;); resolve(&apos;随便什么数据&apos;); &#125;, 2000);&#125;); Promise的构造函数接收一个参数，是函数，并且传入两个参数：resolve，reject，分别表示异步操作执行成功后的回调函数和异步操作执行失败后的回调函数。其实这里用“成功”和“失败”来描述并不准确，按照标准来讲，resolve是将Promise的状态置为fullfiled，reject是将Promise的状态置为rejected。不过在我们开始阶段可以先这么理解，后面再细究概念。 在上面的代码中，我们执行了一个异步操作，也就是setTimeout，2秒后，输出“执行完成”，并且调用resolve方法。 运行代码，会在2秒后输出“执行完成”。注意！我只是new了一个对象，并没有调用它，我们传进去的函数就已经执行了，这是需要注意的一个细节。所以我们用Promise的时候一般是包在一个函数中，在需要的时候去运行这个函数，如： 1234567891011function runAsync()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log(&apos;执行完成&apos;); resolve(&apos;随便什么数据&apos;); &#125;, 2000); &#125;); return p; &#125;runAsync() 这时候你应该有两个疑问：1.包装这么一个函数有毛线用？2.resolve(‘随便什么数据’);这是干毛的？ 我们继续来讲。在我们包装好的函数最后，会return出Promise对象，也就是说，执行这个函数我们得到了一个Promise对象。还记得Promise对象上有then、catch方法吧？这就是强大之处了，看下面的代码： 12345runAsync().then(function(data)&#123; console.log(data); //后面可以用传过来的数据做些其他操作 //......&#125;); 在runAsync()的返回上直接调用then方法，then接收一个参数，是函数，并且会拿到我们在runAsync中调用resolve时传的的参数。运行这段代码，会在2秒后输出“执行完成”，紧接着输出“随便什么数据”。 这时候你应该有所领悟了，原来then里面的函数就跟我们平时的回调函数一个意思，能够在runAsync这个异步任务执行完成之后被执行。这就是Promise的作用了，简单来讲，就是能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。 你可能会不屑一顾，那么牛逼轰轰的Promise就这点能耐？我把回调函数封装一下，给runAsync传进去不也一样吗，就像这样： 12345678910function runAsync(callback)&#123; setTimeout(function()&#123; console.log(&apos;执行完成&apos;); callback(&apos;随便什么数据&apos;); &#125;, 2000);&#125;runAsync(function(data)&#123; console.log(data);&#125;); 效果也是一样的，还费劲用Promise干嘛。那么问题来了，有多层回调该怎么办？如果callback也是一个异步操作，而且执行完后也需要有相应的回调函数，该怎么办呢？总不能再定义一个callback2，然后给callback传进去吧。而Promise的优势在于，可以在then方法中继续写Promise对象并返回，然后继续调用then来进行回调操作。 链式操作的用法所以，从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用，它比传递callback函数要简单、灵活的多。所以使用Promise的正确场景是这样的： 123456789101112runAsync1().then(function(data)&#123; console.log(data); return runAsync2();&#125;).then(function(data)&#123; console.log(data); return runAsync3();&#125;).then(function(data)&#123; console.log(data);&#125;); 这样能够按顺序，每隔两秒输出每个异步回调中的内容，在runAsync2中传给resolve的数据，能在接下来的then方法中拿到。运行结果如下： 异步任务1执行完成随便什么数据1异步任务2执行完成随便什么数据2异步任务3执行完成随便什么数据3 猜猜runAsync1、runAsync2、runAsync3这三个函数都是如何定义的？没错，就是下面这样（代码较长请自行展开）： 123456789101112131415161718192021222324252627282930function runAsync1()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log(&apos;异步任务1执行完成&apos;); resolve(&apos;随便什么数据1&apos;); &#125;, 1000); &#125;); return p; &#125;function runAsync2()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log(&apos;异步任务2执行完成&apos;); resolve(&apos;随便什么数据2&apos;); &#125;, 2000); &#125;); return p; &#125;function runAsync3()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; console.log(&apos;异步任务3执行完成&apos;); resolve(&apos;随便什么数据3&apos;); &#125;, 2000); &#125;); return p; &#125; 在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了，比如我们把上面的代码修改成这样： 123456789101112runAsync1().then(function(data)&#123; console.log(data); return runAsync2();&#125;).then(function(data)&#123; console.log(data); return &apos;直接返回数据&apos;; //这里直接返回数据&#125;).then(function(data)&#123; console.log(data);&#125;); 那么输出就变成了这样： 异步任务1执行完成随便什么数据1异步任务2执行完成随便什么数据2直接返回数据 reject的用法到这里，你应该对“Promise是什么玩意”有了最基本的了解。那么我们接着来看看ES6的Promise还有哪些功能。我们光用了resolve，还没用reject呢，它是做什么的呢？事实上，我们前面的例子都是只有“执行成功”的回调，还没有“失败”的情况，reject的作用就是把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。看下面的代码。 123456789101112131415161718192021222324252627function getNumber()&#123; var p = new Promise(function(resolve, reject)&#123; //做一些异步操作 setTimeout(function()&#123; var num = Math.ceil(Math.random()*10); //生成1-10的随机数 if(num&lt;=5)&#123; resolve(num); &#125; else&#123; reject(&apos;数字太大了&apos;); &#125; &#125;, 2000); &#125;); return p; &#125;getNumber().then( function(data)&#123; console.log(&apos;resolved&apos;); console.log(data); &#125;, function(reason, data)&#123; console.log(&apos;rejected&apos;); console.log(reason); &#125;); getNumber函数用来异步获取一个数字，2秒后执行完成，如果数字小于等于5，我们认为是“成功”了，调用resolve修改Promise的状态。否则我们认为是“失败”了，调用reject并传递一个参数，作为失败的原因。 运行getNumber并且在then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。多次运行这段代码，你会随机得到下面两种结果： resolved1 或者 rejected数字太大了 catch的用法我们知道Promise对象除了then方法，还有一个catch方法，它是做什么用的呢？其实它和then的第二个参数一样，用来指定reject的回调，用法是这样： 123456789getNumber().then(function(data)&#123; console.log(&apos;resolved&apos;); console.log(data);&#125;).catch(function(reason)&#123; console.log(&apos;rejected&apos;); console.log(reason);&#125;); 效果和写在then的第二个参数里面一样。不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。请看下面的代码： 12345678910getNumber().then(function(data)&#123; console.log(&apos;resolved&apos;); console.log(data); console.log(somedata); //此处的somedata未定义&#125;).catch(function(reason)&#123; console.log(&apos;rejected&apos;); console.log(reason);&#125;); 在resolve的回调中，我们console.log(somedata);而somedata这个变量是没有被定义的。如果我们不用Promise，代码运行到这里就直接在控制台报错了，不往下运行了。但是在这里，会得到这样的结果： resolved4rejectedReferenceError: somedata is not defined(…) 也就是说进到catch方法里面去了，而且把错误原因传到了reason参数中。即便是有错误的代码也不会报错了，这与我们的try/catch语句有相同的功能。 all的用法Promise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。我们仍旧使用上面定义好的runAsync1、runAsync2、runAsync3这三个函数，看下面的例子： 12345Promise.all([runAsync1(), runAsync2(), runAsync3()]).then(function(results)&#123; console.log(results);&#125;); 用Promise.all来执行，all接收一个数组参数，里面的值最终都算返回Promise对象。这样，三个异步操作的并行执行的，等到它们都执行完后才会进到then里面。那么，三个异步操作返回的数据哪里去了呢？都在then里面呢，all会把所有异步操作的结果放进一个数组中传给then，就是上面的results。所以上面代码的输出结果就是： 异步任务1执行完成异步任务2执行完成异步任务3执行完成[“随便什么数据1”, “随便什么数据2”, “随便什么数据3”] 有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。 race的用法all方法的效果实际上是「谁跑的慢，以谁为准执行回调」，那么相对的就有另一个方法「谁跑的快，以谁为准执行回调」，这就是race方法，这个词本来就是赛跑的意思。race的用法与all一样，我们把上面runAsync1的延时改为1秒来看一下： 12345Promise.race([runAsync1(), runAsync2(), runAsync3()]).then(function(results)&#123; console.log(results);&#125;); 这三个异步操作同样是并行执行的。结果你应该可以猜到，1秒后runAsync1已经执行完了，此时then里面的就执行了。结果是这样的： 异步任务1执行完成随便什么数据1异步任务2执行完成异步任务3执行完成 你猜对了吗？不完全，是吧。在then里面的回调开始执行时，runAsync2()和runAsync3()并没有停止，仍旧再执行。于是再过1秒后，输出了他们结束的标志。 这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下： 123456789101112131415161718192021222324252627282930//请求某个图片资源function requestImg()&#123; var p = new Promise(function(resolve, reject)&#123; var img = new Image(); img.onload = function()&#123; resolve(img); &#125; img.src = &apos;xxxxxx&apos;; &#125;); return p;&#125;//延时函数，用于给请求计时function timeout()&#123; var p = new Promise(function(resolve, reject)&#123; setTimeout(function()&#123; reject(&apos;图片请求超时&apos;); &#125;, 5000); &#125;); return p;&#125;Promise.race([requestImg(), timeout()]).then(function(results)&#123; console.log(results);&#125;).catch(function(reason)&#123; console.log(reason);&#125;); requestImg函数会异步请求一张图片，我把地址写为”xxxxxx”，所以肯定是无法成功请求到的。timeout函数是一个延时5秒的异步操作。我们把这两个返回Promise对象的函数放进race，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么遍进入then方法，执行正常的流程。如果5秒钟图片还未成功返回，那么timeout就跑赢了，则进入catch，报出“图片请求超时”的信息。运行结果如下： X GET file:///F:/wamp/www/test/promise/xxxxxx net::ERR_FILE_NOT_FOUND图片请求超时 总结ES6 Promise的内容就这些吗？是的，能用到的基本就这些。我怎么还见过done、finally、success、fail等，这些是啥？这些并不在Promise标准中，而是我们自己实现的语法糖。 PS:链式请求会便捷许多。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://walkstreet.github.io/personal-blog/categories/Javascript/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"https://walkstreet.github.io/personal-blog/tags/ajax/"},{"name":"promise","slug":"promise","permalink":"https://walkstreet.github.io/personal-blog/tags/promise/"}]},{"title":"ES6规范","slug":"es6开发规范","date":"2017-05-16T01:49:19.000Z","updated":"2018-02-23T09:47:02.457Z","comments":true,"path":"2017/05/16/es6开发规范/","link":"","permalink":"https://walkstreet.github.io/personal-blog/personal-blog/2017/05/16/es6开发规范/","excerpt":"原始类型：值传递 string number boolean null undefined 123456const foo = 1;let bar = foo;bar = 9;console.log(foo, bar); // =&gt; 1, 9 复杂类型：引用传递 object array function 123456const foo = [1, 2];const bar = foo;bar[0] = 9;console.log(foo[0], bar[0]); // =&gt; 9, 9","text":"原始类型：值传递 string number boolean null undefined 123456const foo = 1;let bar = foo;bar = 9;console.log(foo, bar); // =&gt; 1, 9 复杂类型：引用传递 object array function 123456const foo = [1, 2];const bar = foo;bar[0] = 9;console.log(foo[0], bar[0]); // =&gt; 9, 9 引用 为引用使用 const 关键字，而不是 var 这样确保你不能修改引用类型，否则可能会导致一些 bug 或难以理解的代码。 1234567// badvar a = 1;var b = 2;// goodconst a = 1;const b = 2; 如果你必须修改引用，使用 let 代替 var 因为 let 是块作用域的，而 var 是函数作用域。 1234567891011// badvar count = 1;if (true) &#123; count += 1;&#125;// good, use the let.let count = 1;if (true) &#123; count += 1;&#125; let 和 const 都是块作用域的 1234567// const and let only exist in the blocks they are defined in.&#123; let a = 1; const b = 1;&#125;console.log(a); // ReferenceErrorconsole.log(b); // ReferenceError 对象 使用对象字面量创建对象 12345// badvar item = new Object();// goodvar item = &#123;&#125;; 不要使用 保留字（reserved words） 作为键，否则在 IE8 下将出错， issue 12345678910111213// badvar superman = &#123; class: &apos;superhero&apos;, default: &#123; clark: &apos;kent&apos; &#125;, private: true&#125;;// goodvar superman = &#123; klass: &apos;superhero&apos;, defaults: &#123; clark: &apos;kent&apos; &#125;, hidden: true&#125;; 使用易读的同义词代替保留字 1234567891011121314// badconst superman = &#123; class: &apos;alien&apos;&#125;;// badconst superman = &#123; klass: &apos;alien&apos;&#125;;// goodconst superman = &#123; type: &apos;alien&apos;&#125;; 创建对象时使用计算的属性名，而不要在创建对象后使用对象的动态特性 这样可以在同一个位置定义对象的所有属性。 1234567891011121314151617function getKey(k) &#123; return `a key named $&#123;k&#125;`; &#125; // bad const obj = &#123; id: 5, name: &apos;San Francisco&apos; &#125;; obj[getKey(&apos;enabled&apos;)] = true; // good const obj = &#123; id: 5, name: &apos;San Francisco&apos;, [getKey(&apos;enabled&apos;)]: true &#125;; 使用定义对象方法的简短形式 1234567891011121314151617// badconst atom = &#123; value: 1, addValue: function (value) &#123; return atom.value + value; &#125;&#125;;// goodconst atom = &#123; value: 1, addValue(value) &#123; return atom.value + value; &#125;&#125;; 使用定义对象属性的简短形式 书写起来更加简单，并且可以自描述。 1234567891011const lukeSkywalker = &apos;Luke Skywalker&apos;; // bad const obj = &#123; lukeSkywalker: lukeSkywalker &#125;; // good const obj = &#123; lukeSkywalker &#125;; 将所有简写的属性写在对象定义的最顶部 这样可以更加方便地知道哪些属性使用了简短形式。 12345678910111213141516171819202122const anakinSkywalker = &apos;Anakin Skywalker&apos;; const lukeSkywalker = &apos;Luke Skywalker&apos;; // bad const obj = &#123; episodeOne: 1, twoJedisWalkIntoACantina: 2, lukeSkywalker, episodeThree: 3, mayTheFourth: 4, anakinSkywalker &#125;; // good const obj = &#123; lukeSkywalker, anakinSkywalker, episodeOne: 1, twoJedisWalkIntoACantina: 2, episodeThree: 3, mayTheFourth: 4 &#125;; 数组 使用字面量语法创建数组 12345// badconst items = new Array();// goodconst items = []; 如果你不知道数组的长度，使用 push 12345678const someStack = [];// badsomeStack[someStack.length] = &apos;abracadabra&apos;;// goodsomeStack.push(&apos;abracadabra&apos;); 使用 … 来拷贝数组 1234567891011// badconst len = items.length;const itemsCopy = [];let i;for (i = 0; i &lt; len; i++) &#123; itemsCopy[i] = items[i];&#125;// goodconst itemsCopy = [...items]; 使用 Array.from 将类数组对象转换为数组 12const foo = document.querySelectorAll(&apos;.foo&apos;);const nodes = Array.from(foo); 解构 Destructuring 访问或使用对象的多个属性时请使用对象的解构赋值 解构赋值避免了为这些属性创建临时变量或对象。 123456789101112131415161718// badfunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125;// goodfunction getFullName(obj) &#123; const &#123; firstName, lastName &#125; = obj; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125;// bestfunction getFullName(&#123; firstName, lastName &#125;) &#123; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125; 使用数组解构赋值 12345678const arr = [1, 2, 3, 4];// badconst first = arr[0];const second = arr[1];// goodconst [first, second] = arr; 函数有多个返回值时使用对象解构，而不是数组解构 这样你就可以随时添加新的返回值或任意改变返回值的顺序，而不会导致调用失败。 12345678910111213141516function processInput(input) &#123; // then a miracle occurs return [left, right, top, bottom]; &#125; // the caller needs to think about the order of return data const [left, __, top] = processInput(input); // good function processInput(input) &#123; // then a miracle occurs return &#123; left, right, top, bottom &#125;; &#125; // the caller selects only the data they need const &#123; left, right &#125; = processInput(input); 字符串 使用单引号 ‘’ 1234567891011// badvar name = &quot;Bob Parr&quot;;// goodvar name = &apos;Bob Parr&apos;;// badvar fullName = &quot;Bob &quot; + this.lastName;// goodvar fullName = &apos;Bob &apos; + this.lastName; 超过80个字符的字符串应该使用字符串连接换行 注：如果过度使用长字符串连接可能会对性能有影响。 jsPerf &amp; Discussion 12345678910111213141516171819// badvar errorMessage = &apos;This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.&apos;;// badvar errorMessage = &apos;This is a super long error that \\was thrown because of Batman. \\When you stop to think about \\how Batman had anything to do \\with this, you would get nowhere \\fast.&apos;;// goodvar errorMessage = &apos;This is a super long error that &apos; + &apos;was thrown because of Batman.&apos; + &apos;When you stop to think about &apos; + &apos;how Batman had anything to do &apos; + &apos;with this, you would get nowhere &apos; + &apos;fast.&apos;; 编程构建字符串时，使用字符串模板而不是字符串连接 模板给你一个可读的字符串，简洁的语法与适当的换行和字符串插值特性。 1234567891011121314// badfunction sayHi(name) &#123; return &apos;How are you, &apos; + name + &apos;?&apos;;&#125;// badfunction sayHi(name) &#123; return [&apos;How are you, &apos;, name, &apos;?&apos;].join();&#125;// goodfunction sayHi(name) &#123; return `How are you, $&#123;name&#125;?`;&#125; 函数 使用函数声明而不是函数表达式 函数声明拥有函数名，在调用栈中更加容易识别。并且，函数声明会整体提升，而函数表达式只会提升变量本身。这条规则也可以这样描述，始终使用 箭头函数 来代替函数表达式。 1234567// badconst foo = function () &#123;&#125;;// goodfunction foo() &#123;&#125; 函数表达式 1234// immediately-invoked function expression (IIFE)(() =&gt; &#123; console.log(&apos;Welcome to the Internet. Please follow me.&apos;);&#125;)(); 绝对不要在一个非函数块（if，while，等等）里声明一个函数，把那个函数赋给一个变量。浏览器允许你这么做，但是它们解析不同 注：ECMA-262 把 块 定义为一组语句，函数声明不是一个语句。阅读 ECMA-262 对这个问题的说明 12345678910111213// badif (currentUser) &#123; function test() &#123; console.log(&apos;Nope.&apos;); &#125;&#125;// goodif (currentUser) &#123; var test = function test() &#123; console.log(&apos;Yup.&apos;); &#125;;&#125; 绝对不要把参数命名为 arguments , 这将会覆盖函数作用域内传过来的 arguments 对象 123456789// badfunction nope(name, options, arguments) &#123; // ...stuff...&#125;// goodfunction yup(name, options, args) &#123; // ...stuff...&#125; 永远不要使用 arguments ，使用 ... 操作符来代替 … 操作符可以明确指定你需要哪些参数，并且得到的是一个真实的数组，而不是 arguments 这样的类数组对象。 12345678910// badfunction concatenateAll() &#123; const args = Array.prototype.slice.call(arguments); return args.join(&apos;&apos;);&#125;// goodfunction concatenateAll(...args) &#123; return args.join(&apos;&apos;);&#125; 使用函数参数默认值语法，而不是修改函数的实参 123456789101112131415161718192021// really badfunction handleThings(opts) &#123; // No! We shouldn&apos;t mutate function arguments. // Double bad: if opts is falsy it&apos;ll be set to an object which may // be what you want but it can introduce subtle bugs. opts = opts || &#123;&#125;; // ...&#125;// still badfunction handleThings(opts) &#123; if (opts === void 0) &#123; opts = &#123;&#125;; &#125; // ...&#125;// goodfunction handleThings(opts = &#123;&#125;) &#123; // ...&#125; 箭头函数 Arrow Functions 当必须使用函数表达式时（例如传递一个匿名函数时），请使用箭头函数 箭头函数提供了更简洁的语法，并且箭头函数中 this 对象的指向是不变的， this 对象绑定定义时所在的对象，这通常是我们想要的。如果该函数的逻辑非常复杂，请将该函数提取为一个函数声明。 123456789// bad[1, 2, 3].map(function (x) &#123; return x * x;&#125;);// good[1, 2, 3].map((x) =&gt; &#123; return x * x&#125;); 总是用括号包裹参数，省略括号只适用于单个参数，并且还降低了程序的可读性 12345// bad [1, 2, 3].map(x =&gt; x * x); // good [1, 2, 3].map((x) =&gt; x * x); 构造函数 总是使用 class 关键字，避免直接修改 prototype class 语法更简洁，也更易理解。 12345678910111213141516171819202122// badfunction Queue(contents = []) &#123; this._queue = [...contents];&#125;Queue.prototype.pop = function() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value;&#125;// goodclass Queue &#123; constructor(contents = []) &#123; this._queue = [...contents]; &#125; pop() &#123; const value = this._queue[0]; this._queue.splice(0, 1); return value; &#125;&#125; 使用 extends 关键字来继承 这是一个内置的继承方式，并且不会破坏 instanceof 原型检查。 12345678910111213141516// bad const inherits = require(&apos;inherits&apos;); function PeekableQueue(contents) &#123; Queue.apply(this, contents); &#125; inherits(PeekableQueue, Queue); PeekableQueue.prototype.peek = function() &#123; return this._queue[0]; &#125; // good class PeekableQueue extends Queue &#123; peek() &#123; return this._queue[0]; &#125; &#125; 在方法中返回 this 以方便链式调用 12345678910111213141516171819202122232425262728293031// badJedi.prototype.jump = function() &#123; this.jumping = true; return true;&#125;;Jedi.prototype.setHeight = function(height) &#123; this.height = height;&#125;;const luke = new Jedi();luke.jump(); // =&gt; trueluke.setHeight(20); // =&gt; undefined// goodclass Jedi &#123; jump() &#123; this.jumping = true; return this; &#125; setHeight(height) &#123; this.height = height; return this; &#125;&#125;const luke = new Jedi();luke.jump() .setHeight(20); 可以写一个自定义的toString()方法，但是确保它工作正常并且不会有副作用 12345678910111213class Jedi &#123; contructor(options = &#123;&#125;) &#123; this.name = options.name || &apos;no name&apos;; &#125; getName() &#123; return this.name; &#125; toString() &#123; return `Jedi - $&#123;this.getName()&#125;`; &#125;&#125; 模块 总是在非标准的模块系统中使用标准的 import 和 export 语法，我们总是可以将标准的模块语法转换成支持特定模块加载器的语法。 模块是未来的趋势，那么我们为何不现在就开始使用。 1234567891011// badconst AirbnbStyleGuide = require(&apos;./AirbnbStyleGuide&apos;);module.exports = AirbnbStyleGuide.es6;// okimport AirbnbStyleGuide from &apos;./AirbnbStyleGuide&apos;;export default AirbnbStyleGuide.es6;// bestimport &#123; es6 &#125; from &apos;./AirbnbStyleGuide&apos;;export default es6; 不要使用通配符 * 的 import 这样确保了只有一个默认的 export 项 12345// badimport * as AirbnbStyleGuide from &apos;./AirbnbStyleGuide&apos;;// goodimport AirbnbStyleGuide from &apos;./AirbnbStyleGuide&apos;; 不要直接从一个 import 上 export 虽然一行代码看起来更简洁，但是有一个明确的 import 和一个明确的 export 使得代码行为更加明确。 12345678// bad// filename es6.jsexport default &#123; es6 &#125; from &apos;./airbnbStyleGuide&apos;;// good// filename es6.jsimport &#123; es6 &#125; from &apos;./AirbnbStyleGuide&apos;;export default es6; Iterators 和 Generators 不要使用迭代器（Iterators）。优先使用 JavaScript 中 map 和 reduce 这类高阶函数来代替 for-of 循环 处理纯函数的返回值更加容易并且没有副作用 123456789101112131415161718const numbers = [1, 2, 3, 4, 5]; // bad let sum = 0; for (let num of numbers) &#123; sum += num; &#125; sum === 15; // good let sum = 0; numbers.forEach((num) =&gt; sum += num); sum === 15; // best (use the functional force) const sum = numbers.reduce((total, num) =&gt; total + num, 0); sum === 15; 不要使用 generators 它们不太容易转换为 ES5 的语法。 属性 使用点 . 操作符来访问属性 12345678910const luke = &#123; jedi: true, age: 28&#125;;// badconst isJedi = luke[&apos;jedi&apos;];// goodconst isJedi = luke.jedi; 当使用变量访问属性时使用中括号 [] 12345678910var luke = &#123; jedi: true, age: 28&#125;;function getProp(prop) &#123; return luke[prop];&#125;var isJedi = getProp(&apos;jedi&apos;); 变量 总是使用 const 来声明变量，否则将生成全局变量，我们应该避免污染全局命名空间 12345// badsuperPower = new SuperPower();// goodconst superPower = new SuperPower(); 为每个变量都使用 const 关键字声明 这种方式更加容易添加新变量，并且不必担忧将 , 错误写成 ; 而导致生成全局变量。 123456789101112131415// badconst items = getItems(), goSportsTeam = true, dragonball = &apos;z&apos;;// bad// (compare to above, and try to spot the mistake)const items = getItems(), goSportsTeam = true; dragonball = &apos;z&apos;;// goodconst items = getItems();const goSportsTeam = true;const dragonball = &apos;z&apos;; 将所有 const 变量放在一起，然后将所有 let 变量放在一起 123456789101112131415161718// badlet i, len, dragonball, items = getItems(), goSportsTeam = true;// badlet i;let items = getItems();let dragonball;let goSportsTeam = true;let len;// goodconst goSportsTeam = true;const items = getItems();let dragonball;let i;let length; 在必要的时候声明变量，并且将其放在合适的位置 let 和 const 是块级作用域的，而不是函数作用域。 12345678910111213141516171819202122232425262728293031323334353637// good function() &#123; test(); console.log(&apos;doing stuff..&apos;); //..other stuff.. const name = getName(); if (name === &apos;test&apos;) &#123; return false; &#125; return name; &#125; // bad function() &#123; const name = getName(); if (!arguments.length) &#123; return false; &#125; return true; &#125; // good function() &#123; if (!arguments.length) &#123; return false; &#125; const name = getName(); return true; &#125; 变量提升 Hoisting 通过 var 声明的变量将被提升到作用域的顶部，但他们的赋值不会被提升。通过 const 和 let 声明的变量不存在变量提升，这里有一个新概念，称为“ 暂时性死区（ Temporal Dead Zones (TDZ)） ”。有必要理解 typeof 不再是一个百分之百安全的操作 。 123456789101112131415161718192021222324252627282930// we know this wouldn&apos;t work (assuming there// is no notDefined global variable)function example() &#123; console.log(notDefined); // =&gt; throws a ReferenceError&#125;// creating a variable declaration after you// reference the variable will work due to// variable hoisting. Note: the assignment// value of `true` is not hoisted.function example() &#123; console.log(declaredButNotAssigned); // =&gt; undefined var declaredButNotAssigned = true;&#125;// The interpreter is hoisting the variable// declaration to the top of the scope,// which means our example could be rewritten as:function example() &#123; let declaredButNotAssigned; console.log(declaredButNotAssigned); // =&gt; undefined declaredButNotAssigned = true;&#125;// using const and letfunction example() &#123; console.log(declaredButNotAssigned); // =&gt; throws a ReferenceError console.log(typeof declaredButNotAssigned); // =&gt; throws a ReferenceError const declaredButNotAssigned = true;&#125; 匿名函数表达式提升了对应的变量名，但赋值过程没有被提升 123456789function example() &#123; console.log(anonymous); // =&gt; undefined anonymous(); // =&gt; TypeError anonymous is not a function let anonymous = function() &#123; console.log(&apos;anonymous function expression&apos;); &#125;;&#125; 命名的函数表达式提升了对应的变量名，函数名和函数体没有被提升 1234567891011121314151617181920212223function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function superPower(); // =&gt; ReferenceError superPower is not defined var named = function superPower() &#123; console.log(&apos;Flying&apos;); &#125;;&#125;// the same is true when the function name// is the same as the variable name.function example() &#123; console.log(named); // =&gt; undefined named(); // =&gt; TypeError named is not a function var named = function named() &#123; console.log(&apos;named&apos;); &#125;&#125; 函数声明将被提升 1234567function example() &#123; superPower(); // =&gt; Flying function superPower() &#123; console.log(&apos;Flying&apos;); &#125;&#125; 更多细节可以参考 Ben Cherry 的 JavaScript Scoping &amp; Hoisting 比较运算符和等号 使用 === 和 !== 而不是 == 和 != 比较运算通过 ToBoolean 强制转换并遵循一下规则： Object - true Undefined - false Null - false Booleans - 被转换为对应的值 Number - 值为 +0 ， -0 ， NaN 时为 false ，否则为 true String - 空字符串 ‘’ 为 false ，否则为 true 1234if ([0]) &#123; // true // An array is an object, objects evaluate to true&#125; 使用快捷方式 12345678910111213141516171819// badif (name !== &apos;&apos;) &#123; // ...stuff...&#125;// goodif (name) &#123; // ...stuff...&#125;// badif (collection.length &gt; 0) &#123; // ...stuff...&#125;// goodif (collection.length) &#123; // ...stuff...&#125; 更多细节请阅读 Truth Equality and JavaScript 块 给所有多行的块使用大括号 12345678910111213141516171819// badif (test) return false;// goodif (test) return false;// goodif (test) &#123; return false;&#125;// badfunction() &#123; return false; &#125;// goodfunction() &#123; return false;&#125; 使用 if…else 这样的多行块时，请将 else 和 if 的结束括号放在同一行 12345678910111213141516// badif (test) &#123; thing1(); thing2();&#125;else &#123; thing3();&#125;// goodif (test) &#123; thing1(); thing2();&#125; else &#123; thing3();&#125; 注释 使用 /* … / 进行多行注释，包括描述，指定类型以及参数值和返回值 123456789101112131415161718192021222324252627// bad// make() returns a new element// based on the passed in tag name//// @param &lt;String&gt; tag// @return &lt;Element&gt; elementfunction make(tag) &#123; // ...stuff... return element;&#125;// good/** * make() returns a new element * based on the passed in tag name * * @param &lt;String&gt; tag * @return &lt;Element&gt; element */function make(tag) &#123; // ...stuff... return element;&#125; 使用 // 进行单行注释，将注释放在被注释对象的上面，并在注释之前保留一个空行 12345678910111213141516171819202122232425// badconst active = true; // is current tab// good// is current tabconst active = true;// badfunction getType() &#123; console.log(&apos;fetching type...&apos;); // set the default type to &apos;no type&apos; const type = this._type || &apos;no type&apos;; return type;&#125;// goodfunction getType() &#123; console.log(&apos;fetching type...&apos;); // set the default type to &apos;no type&apos; const type = this._type || &apos;no type&apos;; return type;&#125; 使用 // FIXME: 来注释一个问题 1234567function Calculator() &#123; // FIXME: shouldn&apos;t use a global here total = 0; return this;&#125; 使用 // TODO: 来注释一个问题的解决方案 1234567function Calculator() &#123; // TODO: total should be configurable by an options param this.total = 0; return this;&#125; 空白 将 tab 设置为 2 个空格缩进 1234567891011121314// badfunction() &#123;∙∙∙∙const name;&#125;// badfunction() &#123;∙const name;&#125;// goodfunction() &#123;∙∙const name;&#125; 前大括号前放置一个空格 123456789101112131415161718192021// badfunction test()&#123; console.log(&apos;test&apos;);&#125;// goodfunction test() &#123; console.log(&apos;test&apos;);&#125;// baddog.set(&apos;attr&apos;,&#123; age: &apos;1 year&apos;, breed: &apos;Bernese Mountain Dog&apos;&#125;);// gooddog.set(&apos;attr&apos;, &#123; age: &apos;1 year&apos;, breed: &apos;Bernese Mountain Dog&apos;&#125;); 运算符之间用空格分隔 12345// badconst x=y+5;// goodconst x = y + 5; 文件末尾使用单个换行符 12345678910111213// bad(function(global) &#123; // ...stuff...&#125;)(this);// bad(function(global) &#123; // ...stuff...&#125;)(this);// good(function(global) &#123; // ...stuff...&#125;)(this); 方法链式调用时保持适当的缩进，并且使用前置的 . 来表示该行是一个方法调用，而不是一个新语句 12345678910111213141516171819202122232425262728293031323334// bad$(&apos;#items&apos;).find(&apos;.selected&apos;).highlight().end().find(&apos;.open&apos;).updateCount();// bad$(&apos;#items&apos;). find(&apos;selected&apos;). highlight(). end(). find(&apos;.open&apos;). updateCount();// good$(&apos;#items&apos;) .find(&apos;.selected&apos;) .highlight() .end() .find(&apos;.open&apos;) .updateCount();// badconst leds = stage.selectAll(&apos;.led&apos;).data(data).enter().append(&apos;svg:svg&apos;).class(&apos;led&apos;, true) .attr(&apos;width&apos;, (radius + margin) * 2).append(&apos;svg:g&apos;) .attr(&apos;transform&apos;, &apos;translate(&apos; + (radius + margin) + &apos;,&apos; + (radius + margin) + &apos;)&apos;) .call(tron.led);// goodconst leds = stage.selectAll(&apos;.led&apos;) .data(data) .enter().append(&apos;svg:svg&apos;) .class(&apos;led&apos;, true) .attr(&apos;width&apos;, (radius + margin) * 2) .append(&apos;svg:g&apos;) .attr(&apos;transform&apos;, &apos;translate(&apos; + (radius + margin) + &apos;,&apos; + (radius + margin) + &apos;)&apos;) .call(tron.led); 在语句块之后和下一语句之前都保持一个空行 1234567891011121314151617181920212223242526272829303132// badif (foo) &#123; return bar;&#125;return baz;// goodif (foo) &#123; return bar;&#125;return baz;// badconst obj = &#123; foo: function() &#123; &#125;, bar: function() &#123; &#125;&#125;;return obj;// goodconst obj = &#123; foo: function() &#123; &#125;, bar: function() &#123; &#125;&#125;;return obj; 逗号 不要将逗号放前面 1234567891011121314151617181920212223242526272829// badconst story = [ once , upon , aTime];// goodconst story = [ once, upon, aTime];// badconst hero = &#123; firstName: &apos;Bob&apos; , lastName: &apos;Parr&apos; , heroName: &apos;Mr. Incredible&apos; , superPower: &apos;strength&apos;&#125;;// goodconst hero = &#123; firstName: &apos;Bob&apos;, lastName: &apos;Parr&apos;, heroName: &apos;Mr. Incredible&apos;, superPower: &apos;strength&apos;&#125;; 不要添加多余的逗号，否则将在 IE6/7 和 IE9 的怪异模式下导致错误。同时，某些 ES3 的实现会计算多数组的长度，这在 ES5 中有 澄清 123456789101112131415161718192021// bad const hero = &#123; firstName: &apos;Kevin&apos;, lastName: &apos;Flynn&apos;, &#125;; const heroes = [ &apos;Batman&apos;, &apos;Superman&apos;, ]; // good const hero = &#123; firstName: &apos;Kevin&apos;, lastName: &apos;Flynn&apos; &#125;; const heroes = [ &apos;Batman&apos;, &apos;Superman&apos; ]; 分号 句末一定要添加分号 1234567891011121314151617// bad(function() &#123; const name = &apos;Skywalker&apos; return name&#125;)()// good(() =&gt; &#123; const name = &apos;Skywalker&apos;; return name;&#125;)();// good (guards against the function becoming an argument when two files with IIFEs are concatenated);(() =&gt; &#123; const name = &apos;Skywalker&apos;; return name;&#125;)(); 类型转换 在语句的开始执行类型转换 字符串： 1234567// =&gt; this.reviewScore = 9;// badconst totalScore = this.reviewScore + &apos;&apos;;// goodconst totalScore = String(this.reviewScore); 对数字使用 parseInt 并且总是带上类型转换的基数 12345678910111213141516171819const inputValue = &apos;4&apos;;// badconst val = new Number(inputValue);// badconst val = +inputValue;// badconst val = inputValue &gt;&gt; 0;// badconst val = parseInt(inputValue);// goodconst val = Number(inputValue);// goodconst val = parseInt(inputValue, 10); 不管是出于一些奇特的原因，还是 parseInt 是一个瓶颈而需要位运算来解决某些 性能问题 ，请为你的代码注释为什么要这样做 1234567// good/** * parseInt was the reason my code was slow. * Bitshifting the String to coerce it to a * Number made it a lot faster. */const val = inputValue &gt;&gt; 0; 注意： 使用位移运算时要特别小心。 Number 在 JavaScript 中表示为 64 位的值 ，但位移运算总是返回一个 32 位的整数（ source ），对大于 32 位的整数进行位移运算会导致意外的结果（ 讨论 ）。32 位最大整数为 2,147,483,647 ： 1232147483647 &gt;&gt; 0 //=&gt; 21474836472147483648 &gt;&gt; 0 //=&gt; -21474836482147483649 &gt;&gt; 0 //=&gt; -2147483647 布尔值 12345678910var age = 0;// badvar hasAge = new Boolean(age);// goodvar hasAge = Boolean(age);// goodvar hasAge = !!age; 命名约定 避免单个字符名，让你的变量名有描述意义 123456789// badfunction q() &#123; // ...stuff...&#125;// goodfunction query() &#123; // ..stuff..&#125; 命名对象、函数和实例时使用小驼峰命名规则 123456789101112131415// badvar OBJEcttsssss = &#123;&#125;;var this_is_my_object = &#123;&#125;;var this-is-my-object = &#123;&#125;;function c() &#123;&#125;;var u = new user(&#123; name: &apos;Bob Parr&apos;&#125;);// goodvar thisIsMyObject = &#123;&#125;;function thisIsMyFunction() &#123;&#125;;var user = new User(&#123; name: &apos;Bob Parr&apos;&#125;); 命名构造函数或类时使用大驼峰命名规则 12345678910111213141516171819// badfunction user(options) &#123; this.name = options.name;&#125;const bad = new user(&#123; name: &apos;nope&apos;&#125;);// goodclass User &#123; constructor(options) &#123; this.name = options.name; &#125;&#125;const good = new User(&#123; name: &apos;yup&apos;&#125;); 命名私有属性时前面加个下划线 _ 123456// badthis.__firstName__ = &apos;Panda&apos;;this.firstName_ = &apos;Panda&apos;;// goodthis._firstName = &apos;Panda&apos;; 保存对 this 的引用时使用 _this 1234567891011121314151617181920212223// badfunction() &#123; var self = this; return function() &#123; console.log(self); &#125;;&#125;// badfunction() &#123; var that = this; return function() &#123; console.log(that); &#125;;&#125;// goodfunction() &#123; var _this = this; return function() &#123; console.log(_this); &#125;;&#125; 导出单一一个类时，确保你的文件名就是你的类名 123456789101112131415// file contentsclass CheckBox &#123; // ...&#125;module.exports = CheckBox;// in some other file// badconst CheckBox = require(&apos;./checkBox&apos;);// badconst CheckBox = require(&apos;./check_box&apos;);// goodconst CheckBox = require(&apos;./CheckBox&apos;); 导出一个默认小驼峰命名的函数时，文件名应该就是导出的方法名 1234function makeStyleGuide() &#123;&#125;export default makeStyleGuide; 导出单例、函数库或裸对象时，使用大驼峰命名规则 123456const AirbnbStyleGuide = &#123; es6: &#123; &#125;&#125;;export default AirbnbStyleGuide; 访问器 属性的访问器函数不是必须的 如果你确实有存取器函数的话使用 getVal() 和 setVal(‘hello’) 1234567891011// baddragon.age();// gooddragon.getAge();// baddragon.age(25);// gooddragon.setAge(25); 如果属性是布尔值，使用 isVal() 或 hasVal() 123456789// badif (!dragon.age()) &#123; return false;&#125;// goodif (!dragon.hasAge()) &#123; return false;&#125; 可以创建get()和set()函数，但是要保持一致性 12345678910111213function Jedi(options) &#123; options || (options = &#123;&#125;); var lightsaber = options.lightsaber || &apos;blue&apos;; this.set(&apos;lightsaber&apos;, lightsaber);&#125;Jedi.prototype.set = function(key, val) &#123; this[key] = val;&#125;;Jedi.prototype.get = function(key) &#123; return this[key];&#125;; 事件 当给事件附加数据时，传入一个哈希而不是原始值，这可以让后面的贡献者加入更多数据到事件数据里而不用找出并更新那个事件的##处理器 12345678// bad$(this).trigger(&apos;listingUpdated&apos;, listing.id);...$(this).on(&apos;listingUpdated&apos;, function(e, listingId) &#123; // do something with listingId&#125;); 12345678// good$(this).trigger(&apos;listingUpdated&apos;, &#123; listingId : listing.id &#125;);...$(this).on(&apos;listingUpdated&apos;, function(e, data) &#123; // do something with data.listingId&#125;); jQuery 为 jQuery 对象命名时添加 $ 前缀 12345// badconst sidebar = $(&apos;.sidebar&apos;);// goodconst $sidebar = $(&apos;.sidebar&apos;); 缓存 jQuery 的查询结果 12345678910111213141516171819202122// badfunction setSidebar() &#123; $(&apos;.sidebar&apos;).hide(); // ...stuff... $(&apos;.sidebar&apos;).css(&#123; &apos;background-color&apos;: &apos;pink&apos; &#125;);&#125;// goodfunction setSidebar() &#123; const $sidebar = $(&apos;.sidebar&apos;); $sidebar.hide(); // ...stuff... $sidebar.css(&#123; &apos;background-color&apos;: &apos;pink&apos; &#125;);&#125; 对DOM查询使用级联的 $(&#39;.sidebar ul&#39;) 或 $(&#39;.sidebar ul&#39;) ， jsPerf 在指定作用域进行查询时使用 find 1234567891011121314// bad$(&apos;ul&apos;, &apos;.sidebar&apos;).hide();// bad$(&apos;.sidebar&apos;).find(&apos;ul&apos;).hide();// good$(&apos;.sidebar ul&apos;).hide();// good$(&apos;.sidebar &gt; ul&apos;).hide();// good$sidebar.find(&apos;ul&apos;).hide();","categories":[{"name":"规范","slug":"规范","permalink":"https://walkstreet.github.io/personal-blog/categories/规范/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://walkstreet.github.io/personal-blog/tags/ES6/"},{"name":"Javascript","slug":"Javascript","permalink":"https://walkstreet.github.io/personal-blog/tags/Javascript/"}]},{"title":"html规范","slug":"html规范","date":"2017-05-11T01:41:19.000Z","updated":"2018-02-23T09:47:02.457Z","comments":true,"path":"2017/05/11/html规范/","link":"","permalink":"https://walkstreet.github.io/personal-blog/personal-blog/2017/05/11/html规范/","excerpt":"文档类型推荐使用 HTML5 的文档类型申明： &lt;!DOCTYPE html&gt;.（建议使用 text/html 格式的 HTML。避免使用 XHTML。XHTML 以及它的属性，比如 application/xhtml+xml 在浏览器中的应用支持与优化空间都十分有限）。HTML 中最好不要将无内容元素[1] 的标签闭合，例如：使用 &lt;br&gt; 而非 &lt;br /&gt;. HTML 验证一般情况下，建议使用能通过标准规范验证的 HTML 代码，除非在性能优化和控制文件大小上不得不做出让步。使用诸如 W3C HTML validator 这样的工具来进行检测。规范化的 HTML 是显现技术要求与局限的显著质量基线，它促进了 HTML 被更好地运用。 不推荐12&lt;title&gt;Test&lt;/title&gt;&lt;article&gt;This is only a test.","text":"文档类型推荐使用 HTML5 的文档类型申明： &lt;!DOCTYPE html&gt;.（建议使用 text/html 格式的 HTML。避免使用 XHTML。XHTML 以及它的属性，比如 application/xhtml+xml 在浏览器中的应用支持与优化空间都十分有限）。HTML 中最好不要将无内容元素[1] 的标签闭合，例如：使用 &lt;br&gt; 而非 &lt;br /&gt;. HTML 验证一般情况下，建议使用能通过标准规范验证的 HTML 代码，除非在性能优化和控制文件大小上不得不做出让步。使用诸如 W3C HTML validator 这样的工具来进行检测。规范化的 HTML 是显现技术要求与局限的显著质量基线，它促进了 HTML 被更好地运用。 不推荐12&lt;title&gt;Test&lt;/title&gt;&lt;article&gt;This is only a test. 推荐1234&lt;!DOCTYPE html&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;title&gt;Test&lt;/title&gt;&lt;article&gt;This is only a test.&lt;/article&gt; 省略可选标签 HTML5 规范中规定了 HTML 标签是可以省略的。但从可读性来说，在开发的源文件中最好不要这样做，因为省略标签可能会导致一些问题。省略一些可选的标签确实使得页面大小减少，这很有用，尤其是对于一些大型网站来说。为了达到这一目的，我们可以在开发后期对页面进行压缩处理，在这个环节中这些可选的标签完全就可以省略掉了。 脚本加载出于性能考虑，脚本异步加载很关键。一段脚本放置在 &lt;head&gt; 内，比如 &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;，其加载会一直阻塞 DOM 解析，直至它完全地加载和执行完毕。这会造成页面显示的延迟。特别是一些重量级的脚本，对用户体验来说那真是一个巨大的影响。异步加载脚本可缓解这种性能影响。如果只需兼容 IE10+，可将 HTML5 的 async 属性加至脚本中，它可防止阻塞 DOM 的解析，甚至你可以将脚本引用写在 &lt;head&gt; 里也没有影响。如需兼容老旧的浏览器，实践表明可使用用来动态注入脚本的脚本加载器。你可以考虑 yepnope 或 labjs。注入脚本的一个问题是：一直要等到 CSS 对象文档已就绪，它们才开始加载（短暂地在 CSS 加载完毕之后），这就对需要及时触发的 JS 造成了一定的延迟，这多多少少也影响了用户体验吧。终上所述，兼容老旧浏览器(IE9-)时，应该遵循以下最佳实践。脚本引用写在 body 结束标签之前，并带上 async 属性。这虽然在老旧浏览器中不会异步加载脚本，但它只阻塞了 body 结束标签之前的 DOM 解析，这就大大降低了其阻塞影响。而在现代浏览器中，脚本将在 DOM 解析器发现 body 尾部的 script 标签才进行加载，此时加载属于异步加载，不会阻塞 CSSOM（但其执行仍发生在 CSSOM 之后）。 所有浏览器中，推荐 12345678910&lt;html&gt; &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;main.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- body goes here --&gt; &lt;script src=&quot;main.js&quot; async&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 只在现代浏览器中，推荐 123456789&lt;html&gt; &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;main.css&quot;&gt; &lt;script src=&quot;main.js&quot; async&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- body goes here --&gt; &lt;/body&gt;&lt;/html&gt; 语义化根据元素（有时被错误地称作“标签”）其被创造出来时的初始意义来使用它。打个比方，用 heading 元素来定义头部标题，p 元素来定义文字段落，用 a 元素来定义链接锚点，等等。s有根据有目的地使用 HTML 元素，对于可访问性、代码重用、代码效率来说意义重大。以下示例列出了一些的语义化 HTML 主要情况： 不推荐1234567891011121314151617181920212223242526272829&lt;b&gt;My page title&lt;/b&gt;&lt;div class=&quot;top-navigation&quot;&gt; &lt;div class=&quot;nav-item&quot;&gt;&lt;a href=&quot;#home&quot;&gt;Home&lt;/a&gt;&lt;/div&gt; &lt;div class=&quot;nav-item&quot;&gt;&lt;a href=&quot;#news&quot;&gt;News&lt;/a&gt;&lt;/div&gt; &lt;div class=&quot;nav-item&quot;&gt;&lt;a href=&quot;#about&quot;&gt;About&lt;/a&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;news-page&quot;&gt; &lt;div class=&quot;page-section news&quot;&gt; &lt;div class=&quot;title&quot;&gt;All news articles&lt;/div&gt; &lt;div class=&quot;news-article&quot;&gt; &lt;h2&gt;Bad article&lt;/h2&gt; &lt;div class=&quot;intro&quot;&gt;Introduction sub-title&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;This is a very bad example for HTML semantics&lt;/div&gt; &lt;div class=&quot;article-side-notes&quot;&gt;I think I&apos;m more on the side and should not receive the main credits&lt;/div&gt; &lt;div class=&quot;article-foot-notes&quot;&gt; This article was created by David &lt;div class=&quot;time&quot;&gt;2014-01-01 00:00&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;section-footer&quot;&gt; Related sections: Events, Public holidays &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;page-footer&quot;&gt; Copyright 2014&lt;/div&gt; 推荐12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!-- The page header should go into a header element --&gt;&lt;header&gt; &lt;!-- As this title belongs to the page structure it&apos;s a heading and h1 should be used --&gt; &lt;h1&gt;My page title&lt;/h1&gt;&lt;/header&gt; &lt;!-- All navigation should go into a nav element --&gt;&lt;nav class=&quot;top-navigation&quot;&gt; &lt;!-- A listing of elements should always go to UL (OL for ordered listings) --&gt; &lt;ul&gt; &lt;li class=&quot;nav-item&quot;&gt;&lt;a href=&quot;#home&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt;&lt;a href=&quot;#news&quot;&gt;News&lt;/a&gt;&lt;/li&gt; &lt;li class=&quot;nav-item&quot;&gt;&lt;a href=&quot;#about&quot;&gt;About&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; &lt;!-- The main part of the page should go into a main element (also use role=&quot;main&quot; for accessibility) --&gt;&lt;main class=&quot;news-page&quot; role=&quot;main&quot;&gt; &lt;!-- A section of a page should go into a section element. Divide a page into sections with semantic elements. --&gt; &lt;section class=&quot;page-section news&quot;&gt; &lt;!-- A section header should go into a section element --&gt; &lt;header&gt; &lt;!-- As a page section belongs to the page structure heading elements should be used (in this case h2) --&gt; &lt;h2 class=&quot;title&quot;&gt;All news articles&lt;/h2&gt; &lt;/header&gt; &lt;!-- If a section / module can be seen as an article (news article, blog entry, products teaser, any other re-usable module / section that can occur multiple times on a page) a article element should be used --&gt; &lt;article class=&quot;news-article&quot;&gt; &lt;!-- An article can contain a header that contains the summary / introduction information of the article --&gt; &lt;header&gt; &lt;!-- As a article title does not belong to the overall page structure there should not be any heading tag! --&gt; &lt;div class=&quot;article-title&quot;&gt;Good article&lt;/div&gt; &lt;!-- Small can optionally be used to reduce importance --&gt; &lt;small class=&quot;intro&quot;&gt;Introduction sub-title&lt;/small&gt; &lt;/header&gt; &lt;!-- For the main content in a section or article there is no semantic element --&gt; &lt;div class=&quot;content&quot;&gt; &lt;p&gt;This is a good example for HTML semantics&lt;/p&gt; &lt;/div&gt; &lt;!-- For content that is represented as side note or less important information in a given context use aside --&gt; &lt;aside class=&quot;article-side-notes&quot;&gt; &lt;p&gt;I think I&apos;m more on the side and should not receive the main credits&lt;/p&gt; &lt;/aside&gt; &lt;!-- Articles can also contain footers. If you have footnotes for an article place them into a footer element --&gt; &lt;footer class=&quot;article-foot-notes&quot;&gt; &lt;!-- The time element can be used to annotate a timestamp. Use the datetime attribute to specify ISO time while the actual text in the time element can also be more human readable / relative --&gt; &lt;p&gt;This article was created by David &lt;time datetime=&quot;2014-01-01 00:00&quot; class=&quot;time&quot;&gt;1 month ago&lt;/time&gt;&lt;/p&gt; &lt;/footer&gt; &lt;/article&gt; &lt;!-- In a section, footnotes or similar information can also go into a footer element --&gt; &lt;footer class=&quot;section-footer&quot;&gt; &lt;p&gt;Related sections: Events, Public holidays&lt;/p&gt; &lt;/footer&gt; &lt;/section&gt;&lt;/main&gt; &lt;!-- Your page footer should go into a global footer element --&gt;&lt;footer class=&quot;page-footer&quot;&gt; Copyright 2014&lt;/footer&gt; 多媒体回溯对页面上的媒体而言，像图片、视频、canvas 动画等，要确保其有可替代的接入接口。图片文件我们可采用有意义的备选文本（alt），视频和音频文件我们可以为其加上说明文字或字幕。提供可替代内容对可用性来说十分重要。试想，一位盲人用户如何能知晓一张图片是什么，要是没有 @alt 的话。（图片的 alt 属性是可不填写内容的，纯装饰性的图片就可用这么做：alt=””）。 不推荐1&lt;img src=&quot;luke-skywalker.jpg&quot;&gt; 推荐1&lt;img src=&quot;luke-skywalker.jpg&quot; alt=&quot;Luke skywalker riding an alien horse&quot;&gt; 尽量用 alt 标签去描述图片，设想你需要对于那些只能通过语音或者看不见图片的用户表达图片到底是什么。 不推荐1&lt;img src=&quot;huge-spaceship-approaching-earth.jpg&quot; alt=&quot;Header image&quot;&gt; 推荐1&lt;img src=&quot;huge-spaceship-approaching-earth.jpg&quot; alt=&quot;A huge spaceship that is approaching the earth&quot;&gt; 关注点分离理解 web 中如何和为何区分不同的关注点，这很重要。这里的关注点主要指的是：信息（HTML 结构）、外观（CSS）和行为（JavaScript）。为了使它们成为可维护的干净整洁的代码，我们要尽可能的将它们分离开来。严格地保证结构、表现、行为三者分离，并尽量使三者之间没有太多的交互和联系。就是说，尽量在文档和模板中只包含结构性的 HTML；而将所有表现代码，移入样式表中；将所有动作行为，移入脚本之中。在此之外，为使得它们之间的联系尽可能的小，在文档和模板中也尽量少地引入样式和脚本文件。清晰的分层意味着： 不使用超过一到两张样式表（i.e. main.css, vendor.css） 不使用超过一到两个脚本（学会用合并脚本） 不使用行内样式（&lt;style&gt;.no-good {}&lt;/style&gt;） 不在元素上使用 style 属性（&lt;hr style=&quot;border-top: 5px solid black&quot;&gt;） 不使用行内脚本（&lt;script&gt;alert(&#39;no good&#39;)&lt;/script&gt;） 不使用表象元素（i.e. &lt;b&gt;, &lt;u&gt;, &lt;center&gt;, &lt;font&gt;, &lt;b&gt;） 不使用表象 class 名（i.e. red, left, center） 不推荐123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;base.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;grid.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;type.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;modules/teaser.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 style=&quot;font-size: 3rem&quot;&gt;&lt;/h1&gt; &lt;b&gt;I&apos;m a subtitle and I&apos;m bold!&lt;/b&gt; &lt;center&gt;Dare you center me!&lt;/center&gt; &lt;script&gt; alert(&apos;Just dont...&apos;); &lt;/script&gt; &lt;div class=&quot;red&quot;&gt;I&apos;m important!&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 推荐123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;!-- Concatinate your style sheets into a single one --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;main.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- Don&apos;t use style attributes but assign sensible classes and apply styles in the stylesheet --&gt; &lt;h1 class=&quot;title&quot;&gt;&lt;/h1&gt; &lt;!-- Don&apos;t use presentational elements and assign sensible classes --&gt; &lt;div class=&quot;sub-title&quot;&gt;I&apos;m a subtitle and I&apos;m bold!&lt;/div&gt; &lt;!-- Maybe your comments get centered in your presentation but that decision is up to the stylesheet --&gt; &lt;span class=&quot;comment&quot;&gt;Dare you center me!&lt;/span&gt; &lt;!-- You wanted to make it red because it&apos;s important so then also name the class important and decide in the stylesheet what you want to do with it --&gt; &lt;div class=&quot;important&quot;&gt;I&apos;m important!&lt;/div&gt; &lt;!-- Put all your scripts into files and concatinate them into a single one --&gt; &lt;script async src=&quot;main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; HTML 内容至上不要让非内容信息污染了你的 HTML。现在貌似有一种倾向：通过 HTML 来解决设计问题，这是显然是不对的。HTML 就应该只关注内容。HTML 标签的目的，就是为了不断地展示内容信息。 不要引入一些特定的 HTML 结构来解决一些视觉设计问题 不要将 img 元素当做专门用来做视觉设计的元素以下例子展示了误将 HTML 用来解决设计问题的这两种情况： 不推荐html 代码:12345&lt;!-- We should not introduce an additional element just to solve a design problem --&gt;&lt;span class=&quot;text-box&quot;&gt; &lt;span class=&quot;square&quot;&gt;&lt;/span&gt; See the square next to me?&lt;/span&gt; css 代码:123456.text-box &gt; .square &#123; display: inline-block; width: 1rem; height: 1rem; background-color: red;&#125; 推荐html 代码:1234&lt;!-- That&apos;s clean markup! --&gt;&lt;span class=&quot;text-box&quot;&gt; See the square next to me?&lt;/span&gt; css 代码:12345678/* We use a :before pseudo element to solve the design problem of placing a colored square in front of the text content */.text-box:before &#123; content: &quot;&quot;; display: inline-block; width: 1rem; height: 1rem; background-color: red;&#125; 图片和 SVG 图形能被引入到 HTML 中的唯一理由是它们呈现出了与内容相关的一些信息。 不推荐12345&lt;!-- Content images should never be used for design elements! --&gt;&lt;span class=&quot;text-box&quot;&gt; &lt;img src=&quot;square.svg&quot; alt=&quot;Square&quot; /&gt; See the square next to me?&lt;/span&gt; 推荐html 代码:1234&lt;!-- That&apos;s clean markup! --&gt;&lt;span class=&quot;text-box&quot;&gt; See the square next to me?&lt;/span&gt; css 代码:123456789/* We use a :before pseudo element with a background image to solve the problem */.text-box:before &#123; content: &quot;&quot;; display: inline-block; width: 1rem; height: 1rem; background: url(square.svg) no-repeat; background-size: 100%;&#125; Type 属性省略样式表与脚本上的 type 属性。鉴于 HTML5 中以上两者默认的 type 值就是 text/css 和 text/javascript，所以 type 属性一般是可以忽略掉的。甚至在老旧版本的浏览器中这么做也是安全可靠的。 不推荐12&lt;link rel=&quot;stylesheet&quot; href=&quot;main.css&quot; type=&quot;text/css&quot;&gt;&lt;script src=&quot;main.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 推荐12&lt;link rel=&quot;stylesheet&quot; href=&quot;main.css&quot;&gt;&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt; 可用性如果 HTML5 语义化标签使用得当，许多可用性问题已经引刃而解。ARIA 规则在一些语义化的元素上可为其添上默认的可用性角色属性，使用得当的话已使网站的可用性大部分成立。假如你使用 nav, aside, main, footer 等元素，ARIA 规则会在其上应用一些关联的默认值。更多细节可参考 ARIA specification另外一些角色属性则能够用来呈现更多可用性情景（i.e. role=&quot;tab&quot;）。 Tab Index 在可用性上的运用检查文档中的 tab 切换顺序并传值给元素上的 tabindex，这可以依据元素的重要性来重新排列其 tab 切换顺序。你可以设置 tabindex=&quot;-1&quot; 在任何元素上来禁用其 tab 切换。当你在一个默认不可聚焦的元素上增加了功能，你应该总是为其加上 tabindex 属性使其变为可聚焦状态，而且这也会激活其 CSS 的伪类 :focus。选择合适的 tabindex 值，或是直接使用 tabindex=&quot;0&quot; 将元素们组织成同一 tab 顺序水平，并强制干预其自然阅读顺序。 微格式在 SEO 和可用性上的运用如果 SEO 和可用性环境条件允许的话，建议考虑采用微格式。微格式是通过在元素标签上申明一系列特定数据来达成特定语义的方法。谷歌、微软和雅虎对如何使用这些额外的数据一定程度上的达成一致，如果正确的使用，这将给搜索引擎优化带来巨大的好处。你可以访问 schema.org 获得更多内容细节。看一个电影网站的简单例子： 不带微格式123456&lt;div&gt; &lt;h1&gt;Avatar&lt;/h1&gt; &lt;span&gt;Director: James Cameron (born August 16, 1954)&lt;/span&gt; &lt;span&gt;Science fiction&lt;/span&gt; &lt;a href=&quot;../movies/avatar-theatrical-trailer.html&quot;&gt;Trailer&lt;/a&gt;&lt;/div&gt; 带有微格式12345678&lt;div itemscope itemtype =&quot;http://schema.org/Movie&quot;&gt; &lt;h1 itemprop=&quot;name&quot;&gt;Avatar&lt;/h1&gt; &lt;div itemprop=&quot;director&quot; itemscope itemtype=&quot;http://schema.org/Person&quot;&gt; Director: &lt;span itemprop=&quot;name&quot;&gt;James Cameron&lt;/span&gt; (born &lt;span itemprop=&quot;birthDate&quot;&gt;August 16, 1954)&lt;/span&gt; &lt;/div&gt; &lt;span itemprop=&quot;genre&quot;&gt;Science fiction&lt;/span&gt; &lt;a href=&quot;../movies/avatar-theatrical-trailer.html&quot; itemprop=&quot;trailer&quot;&gt;Trailer&lt;/a&gt;&lt;/div&gt; ID 和锚点通常一个比较好的做法是将页面内所有的头部标题元素都加上 ID. 这样做，页面 URL 的 hash 中带上对应的 ID 名称，即形成描点，方便跳转至对应元素所处位置。打个比方，当你在浏览器中输入 URL http://your-site.com/about#best-practices，浏览器将定位至以下 H3 上。 1&lt;h3 id=&quot;best-practices&quot;&gt;Best practices&lt;/h3&gt; 格式化规则在每一个块状元素，列表元素和表格元素后，加上一新空白行，并对其子孙元素进行缩进。内联元素写在一行内，块状元素还有列表和表格要另起一行。（如果由于换行的空格引发了不可预计的问题，那将所有元素并入一行也是可以接受的，格式警告总好过错误警告）。 推荐123456789101112131415161718192021222324&lt;blockquote&gt; &lt;p&gt;&lt;em&gt;Space&lt;/em&gt;, the final frontier.&lt;/p&gt;&lt;/blockquote&gt; &lt;ul&gt; &lt;li&gt;Moe&lt;/li&gt; &lt;li&gt;Larry&lt;/li&gt; &lt;li&gt;Curly&lt;/li&gt;&lt;/ul&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th scope=&quot;col&quot;&gt;Income&lt;/th&gt; &lt;th scope=&quot;col&quot;&gt;Taxes&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;$ 5.00&lt;/td&gt; &lt;td&gt;$ 4.50&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; HTML 引号使用双引号(“”) 而不是单引号(”) 。 不推荐1&lt;div class=&apos;news-article&apos;&gt;&lt;/div&gt; 推荐1&lt;div class=&quot;news-article&quot;&gt;&lt;/div&gt; [1]: 此处的空白元素指的是以下元素：area, base, br, col, command, embed, hr, img, input, keygen, link, meta, param, source, track, wbr","categories":[{"name":"规范","slug":"规范","permalink":"https://walkstreet.github.io/personal-blog/categories/规范/"}],"tags":[{"name":"html5","slug":"html5","permalink":"https://walkstreet.github.io/personal-blog/tags/html5/"}]},{"title":"Css/Sass规范","slug":"css规范","date":"2017-05-10T14:26:27.000Z","updated":"2018-02-23T09:47:02.456Z","comments":true,"path":"2017/05/10/css规范/","link":"","permalink":"https://walkstreet.github.io/personal-blog/personal-blog/2017/05/10/css规范/","excerpt":"ID和class命名规则ID和class(类)名总是使用可以反应元素目的和用途的名称，或其他通用名称。代替表象和晦涩难懂的名称。 应该首选具体和反映元素目的的名称，因为这些是最可以理解的，而且发生变化的可能性最小。 通用名称只是多个元素的备用名，他们兄弟元素之间是一样的，没有特别意义。区分他们，使他们具有特殊意义，通常需要为“帮手”。 尽管class(类)名和ID 的语义化对于计算机解析来说没有什么实际的意义，语义化的名称 通常是正确的选择，因为它们所代表的信息含义，不包含表现的限制。 不推荐1234567.fw-800 &#123; font-weight: 800;&#125; .red &#123; color: red;&#125; 推荐1234567.heavy &#123; font-weight: 800;&#125; .important &#123; color: red;&#125;","text":"ID和class命名规则ID和class(类)名总是使用可以反应元素目的和用途的名称，或其他通用名称。代替表象和晦涩难懂的名称。 应该首选具体和反映元素目的的名称，因为这些是最可以理解的，而且发生变化的可能性最小。 通用名称只是多个元素的备用名，他们兄弟元素之间是一样的，没有特别意义。区分他们，使他们具有特殊意义，通常需要为“帮手”。 尽管class(类)名和ID 的语义化对于计算机解析来说没有什么实际的意义，语义化的名称 通常是正确的选择，因为它们所代表的信息含义，不包含表现的限制。 不推荐1234567.fw-800 &#123; font-weight: 800;&#125; .red &#123; color: red;&#125; 推荐1234567.heavy &#123; font-weight: 800;&#125; .important &#123; color: red;&#125; 合理避免使用ID一般情况下ID不应该被应用于样式。ID的样式不能被复用并且每个页面中你只能使用一次ID。使用ID唯一有效的是确定网页或整个站点中的位置。尽管如此，你应该始终考虑使用class，而不是id，除非只使用一次。 不推荐123#content .title &#123; font-size: 2em;&#125; 推荐123.content .title &#123; font-size: 2em;&#125; 另一个反对使用ID的观点是含有ID选择器权重很高。一个只包含一个ID选择器权重高于包含1000个class(类)名的选择器，这使得它很奇怪。 123456789// 这个选择器权重高于下面的选择器#content .title &#123; color: red;&#125; // than this selector!html body div.content.news-content .title.content-title.important &#123; color: blue;&#125; 尽可能的精确很多前端开发人员写选择器链的时候不使用 直接子选择器（注：直接子选择器和后代选择器的区别）。有时，这可能会导致疼痛的设计问题并且有时候可能会很耗性能。然而，在任何情况下，这是一个非常不好的做法。如果你不写很通用的，需要匹配到DOM末端的选择器， 你应该总是考虑直接子选择器。 考虑下面的DOM: 123456789101112131415&lt;article class=&quot;content news-content&quot;&gt; &lt;span class=&quot;title&quot;&gt;News event&lt;/span&gt; &lt;div class=&quot;content-body&quot;&gt; &lt;div class=&quot;title content-title&quot;&gt; Check this out &lt;/div&gt; &lt;p&gt;This is a news article content&lt;/p&gt; &lt;div class=&quot;teaser&quot;&gt; &lt;div class=&quot;title&quot;&gt;Buy this&lt;/div&gt; &lt;div class=&quot;teaser-content&quot;&gt;Yey!&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/article&gt; 下面的CSS将应用于有title类的全部三个元素。然后，要解决content类下的title类 和 teaser类下的title类下不同的样式，这将需要更精确的选择器再次重写他们的样式。 不推荐123.content .title &#123; font-size: 2rem;&#125; 推荐1234567891011.content &gt; .title &#123; font-size: 2rem;&#125; .content &gt; .content-body &gt; .title &#123; font-size: 1.5rem;&#125; .content &gt; .content-body &gt; .teaser &gt; .title &#123; font-size: 1.2rem;&#125; 缩写属性CSS提供了各种缩写属性（如 font 字体）应该尽可能使用，即使在只设置一个值的情况下。 使用缩写属性对于代码效率和可读性是有很有用的。 不推荐12345678border-top-style: none;font-family: palatino, georgia, serif;font-size: 100%;line-height: 1.6;padding-bottom: 2em;padding-left: 1em;padding-right: 1em;padding-top: 0; 推荐123border-top: 0;font: 100%/1.6 palatino, georgia, serif;padding: 0 1em 2em; 0和单位省略“0”值后面的单位。不要在0值后面使用单位，除非有值。 不推荐12padding-bottom: 0px;margin: 0em; 推荐12padding-bottom: 0;margin: 0; 十六进制表示法在可能的情况下，使用3个字符的十六进制表示法。颜色值允许这样表示，3个字符的十六进制表示法更简短。 始终使用小写的十六进制数字。 不推荐1color: #FF33AA; 推荐1color: #f3a; ID 和 Class（类） 名的分隔符使用连字符（中划线）分隔ID和Class（类）名中的单词。为了增强课理解性，在选择器中不要使用除了连字符（中划线）以为的任何字符（包括没有）来连接单词和缩写。 另外，作为该标准，预设属性选择器能识别连字符（中划线）作为单词[attribute|=value]的分隔符，所以最好的坚持使用连字符作为分隔符。 不推荐12.demoimage &#123;&#125;.error_status &#123;&#125; 推荐12#video-id &#123;&#125;.ads-sample &#123;&#125; Hacks避免用户代理检测以及CSS“hacks” – 首先尝试不同的方法。通过用户代理检测或特殊的CSS滤镜，变通的方法和 hacks 很容易解决样式差异。为了达到并保持一个有效的和可管理的代码库，这两种方法都应该被认为是最后的手段。换句话说，从长远来看，用户代理检测和hacks会伤害项目，作为项目往往应该采取阻力最小的途径。也就是说，轻易允许使用用户代理检测和hacks 以后将过于频繁。 声明顺序这是一个选择器内书写CSS属性顺序的大致轮廓。这是为了保证更好的可读性和可扫描重要。 作为最佳实践，我们应该遵循以下顺序（应该按照下表的顺序）： 结构性属性： display position, left, top, right etc. overflow, float, clear etc. margin, padding 表现性属性： background, border etc. font, text 不推荐1234567891011121314.box &#123; font-family: &apos;Arial&apos;, sans-serif; border: 3px solid #ddd; left: 30%; position: absolute; text-transform: uppercase; background-color: #eee; right: 30%; isplay: block; font-size: 1.5rem; overflow: hidden; padding: 1em; margin: 1em;&#125; 推荐1234567891011121314.box &#123; display: block; position: absolute; left: 30%; right: 30%; overflow: hidden; margin: 1em; padding: 1em; background-color: #eee; border: 3px solid #ddd; font-family: &apos;Arial&apos;, sans-serif; font-size: 1.5rem; text-transform: uppercase;&#125; 声明结束为了保证一致性和可扩展性，每个声明应该用分号结束，每个声明换行。 不推荐123.test &#123; display: block; height: 100px&#125; 推荐1234.test &#123; display: block; height: 100px;&#125; 属性名结束属性名的冒号后使用一个空格。出于一致性的原因，属性和值（但属性和冒号之间没有空格）的之间始终使用一个空格。 不推荐123h3 &#123; font-weight:bold;&#125; 推荐123h3 &#123; font-weight: bold;&#125; 选择器和声明分离每个选择器和属性声明总是使用新的一行。 不推荐123a:focus, a:active &#123; position: relative; top: 1px;&#125; 推荐123456h1,h2,h3 &#123; font-weight: normal; line-height: 1.2;&#125; 规则分隔规则之间始终有一个空行（双换行符）分隔。 推荐12345678html &#123; background: #fff;&#125; body &#123; margin: auto; width: 50%;&#125; CSS引号属性选择器或属性值用双引号（””），而不是单引号（”）括起来。URI值（url()）不要使用引号。 不推荐123456789@import url(&apos;//cdn.com/foundation.css&apos;); html &#123; font-family: &apos;open sans&apos;, arial, sans-serif;&#125; body:after &#123; content: &apos;pause&apos;;&#125; 推荐123456789@import url(//cdn.com/foundation.css); html &#123; font-family: &quot;open sans&quot;, arial, sans-serif;&#125; body:after &#123; content: &quot;pause&quot;;&#125; 选择器嵌套 (SCSS)在Sass中你可以嵌套选择器，这可以使代码变得更清洁和可读。嵌套所有的选择器，但尽量避免嵌套没有任何内容的选择器。如果你需要指定一些子元素的样式属性，而父元素将不什么样式属性，可以使用常规的CSS选择器链。这将防止您的脚本看起来过于复杂。 不推荐12345678// Not a good example by not making use of nesting at all.content &#123; display: block;&#125; .content &gt; .news-article &gt; .title &#123; font-size: 1.2em;&#125; 不推荐12345678910111213141516171819202122// Using nesting is better but not in all cases// Avoid nesting when there is no attributes and use selector chains instead.content &#123; display: block; &gt; .news-article &#123; &gt; .title &#123; font-size: 1.2em; &#125; &#125;&#125;推荐css 代码:// This example takes the best approach while nesting but use selector chains where possible.content &#123; display: block; &gt; .news-article &gt; .title &#123; font-size: 1.2em; &#125;&#125; 嵌套中引入 空行 (SCSS)嵌套选择器和CSS属性之间空一行。 不推荐123456789101112.content &#123; display: block; &gt; .news-article &#123; background-color: #eee; &gt; .title &#123; font-size: 1.2em; &#125; &gt; .article-footnote &#123; font-size: 0.8em; &#125; &#125;&#125; 推荐123456789101112131415.content &#123; display: block; &gt; .news-article &#123; background-color: #eee; &gt; .title &#123; font-size: 1.2em; &#125; &gt; .article-footnote &#123; font-size: 0.8em; &#125; &#125;&#125; 上下文媒体查询(SCSS)在Sass中，当你嵌套你的选择器时也可以使用上下文媒体查询。在Sass中，你可以在任何给定的嵌套层次中使用媒体查询。由此生成的CSS将被转换，这样的媒体查询将包裹选择器的形式呈现。 这技术非常方便，有助于保持媒体查询属于的上下文。 第一种方法这可以让你先写你的手机样式，然后在任何你需要的地方用上下文媒体查询以提供桌面样式。 不推荐1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// This mobile first example looks like plain CSS where the whole structure of SCSS is repeated// on the bottom in a media query. This is error prone and makes maintenance harder as it&apos;s not so easy to relate// the content in the media query to the content in the upper part (mobile style) .content-page &#123; font-size: 1.2rem; &gt; .main &#123; background-color: whitesmoke; &gt; .latest-news &#123; padding: 1rem; &gt; .news-article &#123; padding: 1rem; &gt; .title &#123; font-size: 2rem; &#125; &#125; &#125; &gt; .content &#123; margin-top: 2rem; padding: 1rem; &#125; &#125; &gt; .page-footer &#123; margin-top: 2rem; font-size: 1rem; &#125;&#125; @media screen and (min-width: 641px) &#123; .content-page &#123; font-size: 1rem; &gt; .main &gt; .latest-news &gt; .news-article &gt; .title &#123; font-size: 3rem; &#125; &gt; .page-footer &#123; font-size: 0.8rem; &#125; &#125;&#125; 推荐1234567891011121314151617181920212223242526272829303132333435363738394041424344// This is the same example as above but here we use contextual media queries in order to put the different styles// for different media into the right context. .content-page &#123; font-size: 1.2rem; @media screen and (min-width: 641px) &#123; font-size: 1rem; &#125; &gt; .main &#123; background-color: whitesmoke; &gt; .latest-news &#123; padding: 1rem; &gt; .news-article &#123; padding: 1rem; &gt; .title &#123; font-size: 2rem; @media screen and (min-width: 641px) &#123; font-size: 3rem; &#125; &#125; &#125; &#125; &gt; .content &#123; margin-top: 2rem; padding: 1rem; &#125; &#125; &gt; .page-footer &#123; margin-top: 2rem; font-size: 1rem; @media screen and (min-width: 641px) &#123; font-size: 0.8rem; &#125; &#125;&#125; 嵌套顺序和父级选择器(SCSS)当使用Sass的嵌套功能的时候，重要的是有一个明确的嵌套顺序，以下内容是一个SCSS块应具有的顺序。 当前选择器的样式属性父级选择器的伪类选择器 (:first-letter, :hover, :active etc)伪类元素 (:before and :after)父级选择器的声明样式 (.selected, .active, .enlarged etc.)用Sass的上下文媒体查询子选择器作为最后的部分The following example should illustrate how this ordering will achieve a clear structure while making use of the Sass parent selector. Recommended 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253.product-teaser &#123; // 1. Style attributes display: inline-block; padding: 1rem; background-color: whitesmoke; color: grey; // 2. Pseudo selectors with parent selector &amp;:hover &#123; color: black; &#125; // 3. Pseudo elements with parent selector &amp;:before &#123; content: &quot;&quot;; display: block; border-top: 1px solid grey; &#125; &amp;:after &#123; content: &quot;&quot;; display: block; border-top: 1px solid grey; &#125; // 4. State classes with parent selector &amp;.active &#123; background-color: pink; color: red; // 4.2. Pseuso selector in state class selector &amp;:hover &#123; color: darkred; &#125; &#125; // 5. Contextual media queries @media screen and (max-width: 640px) &#123; display: block; font-size: 2em; &#125; // 6. Sub selectors &gt; .content &gt; .title &#123; font-size: 1.2em; // 6.5. Contextual media queries in sub selector @media screen and (max-width: 640px) &#123; letter-spacing: 0.2em; text-transform: uppercase; &#125; &#125;&#125;","categories":[{"name":"规范","slug":"规范","permalink":"https://walkstreet.github.io/personal-blog/categories/规范/"}],"tags":[{"name":"css","slug":"css","permalink":"https://walkstreet.github.io/personal-blog/tags/css/"},{"name":"sass","slug":"sass","permalink":"https://walkstreet.github.io/personal-blog/tags/sass/"}]},{"title":"Vue插件编写","slug":"Vue插件编写","date":"2017-04-26T02:30:27.000Z","updated":"2018-02-23T09:47:02.455Z","comments":true,"path":"2017/04/26/Vue插件编写/","link":"","permalink":"https://walkstreet.github.io/personal-blog/personal-blog/2017/04/26/Vue插件编写/","excerpt":"写个插件引用https://vuefe.cn/guide/plugins.html 1.在components 目录下新建一个validate.js：12345export default&#123; install(Vue)&#123; Vue.prototype.$myName = &quot;zhagngsan&quot;; &#125;&#125; 这就是我们的插件，定义了一个属性 2.入口文件jssrc/index.js 加入：1234// 引入import validate from &quot;./../components/validate&quot;;// 使用Vue.use(validate); 3.我们到user-username.vue 组件下验证一下:123mounted()&#123; alert(this.$myName);&#125;, 浏览器成功弹出alert 4.刚刚我们已经学会插件里定义属性，马上来学一下如何定义方法：","text":"写个插件引用https://vuefe.cn/guide/plugins.html 1.在components 目录下新建一个validate.js：12345export default&#123; install(Vue)&#123; Vue.prototype.$myName = &quot;zhagngsan&quot;; &#125;&#125; 这就是我们的插件，定义了一个属性 2.入口文件jssrc/index.js 加入：1234// 引入import validate from &quot;./../components/validate&quot;;// 使用Vue.use(validate); 3.我们到user-username.vue 组件下验证一下:123mounted()&#123; alert(this.$myName);&#125;, 浏览器成功弹出alert 4.刚刚我们已经学会插件里定义属性，马上来学一下如何定义方法： 123456789101112export default&#123; install(Vue)&#123; // Vue.prototype.$myName = &quot;zhagngsan&quot;; Vue.prototype.checkUserName = (value) =&gt; &#123; if(/\\w&#123;6,20&#125;/.test(value))&#123; return true; &#125;else&#123; return false; &#125; &#125; &#125;&#125; 同样可以使用该方法： 12345if(this.checkUserName(&quot;hello&quot;))&#123; alert(&quot;ok&quot;);&#125;else&#123; alert(&quot;error&quot;);&#125; 我们修改user-name.vue 组件，来实现文本框验证：1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label class=&quot;col-sm-2 control-label&quot;&gt;用户名&lt;/label&gt; &lt;div class=&quot;col-sm-10&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;username&quot; v-on:change=&quot;userNameChange&quot; class=&quot;form-control&quot; :placeholder=&quot;username&quot;&gt; &lt;label class=&quot;label label-danger&quot; v-if=&quot;showErrorLabel&quot;&gt;用户不合法&lt;/label&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; props:[&quot;placeholder&quot;], data:function () &#123; return &#123; username:&quot;&quot;, showErrorLabel:false, &#125; &#125;, methods:&#123; userNameChange()&#123; // 用户名改变的方法里判断 用户名是否复合要求 if(this.checkUserName(this.username))&#123; this.showErrorLabel = false; // 如果验证没有通过就显示错误提示 &#125;else&#123; this.showErrorLabel = true; &#125; // 调用父组件的方法 this.$emit(&quot;childChange&quot;,&quot;username&quot;,this.username) &#125; &#125; &#125;&lt;/script&gt; 自定义指令引用https://vuefe.cn/guide/custom-directive.html validate.js:123456789101112131415161718192021222324252627export default&#123; install(Vue)&#123; // Vue.prototype.$myName = &quot;zhagngsan&quot;; Vue.prototype.checkUserName = (value) =&gt; &#123; if(value == &quot;&quot;)&#123; return true; // 如果没有填写,默认为true &#125; if(/\\w&#123;6,20&#125;/.test(value))&#123; return true; &#125;else&#123; return false; &#125; &#125; Vue.directive(&quot;uname&quot;,&#123; bind()&#123; console.log(&quot;bind&quot;); // 只会调用一次 &#125;, update(el,binding,vnode)&#123; console.log(el); console.log(binding); console.log(vnode); &#125;, &#125;) &#125;&#125; 2、我们自定了一个uname 指令，下面来看一下如何使用的？1&lt;input type=&quot;text&quot; v-uname=&quot;username&quot; v-model=&quot;username&quot; v-on:change=&quot;userNameChange&quot; class=&quot;form-control&quot; :placeholder=&quot;username&quot;&gt; 我们在组件的模板里使用了 v-uname ，并且给绑定了”username”数据。 我们打开浏览器的控制台：> bind 说明我们定义的指令里，这个方法执行了： 123bind()&#123; console.log(&quot;bind&quot;); // 只会调用一次&#125;, 3.下面我们来看一下update 里的东东12345update(el,binding,vnode)&#123; console.log(el); console.log(binding); console.log(vnode);&#125; 引用文档https://vuefe.cn/guide/custom-directive.html","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://walkstreet.github.io/personal-blog/categories/Javascript/"}],"tags":[{"name":"Vue2.0","slug":"Vue2-0","permalink":"https://walkstreet.github.io/personal-blog/tags/Vue2-0/"},{"name":"Vue插件","slug":"Vue插件","permalink":"https://walkstreet.github.io/personal-blog/tags/Vue插件/"}]},{"title":"前端面试题-JS防抖动","slug":"js-shake","date":"2017-04-10T06:03:00.000Z","updated":"2018-02-23T09:47:02.457Z","comments":true,"path":"2017/04/10/js-shake/","link":"","permalink":"https://walkstreet.github.io/personal-blog/personal-blog/2017/04/10/js-shake/","excerpt":"在某些信息列表中一般采用瀑布流，滚动一屏时加载相应的数据，请思考如何避免连续下拉时而产生的问题（可能是页面崩溃，也可能是巨卡无比）。一般碰到这样的面试题，防抖动机制，就能很好的解决，这方面最早的应用实践还是Twitter，开发者写了一篇博客，详细的阐述了如何解决这样的问题。那么，说道防抖动，其核心内涵在于延迟处理，也就是将一系列的事件处理程序全部延迟，保障推送近来的第一次事件处理。 12345678910event.on(&apos;scroll&apos;,function(e)&#123; var fun; return function()&#123; if(fun) clearTimeout(fun); fun = setTimeout(function()&#123; // console.log(&apos;1&apos;) &#125;,500) &#125;&#125;) 这是最常见的一种方式，如果scroll的次数较多时，可以先将真实的函数放置在定时器中。","text":"在某些信息列表中一般采用瀑布流，滚动一屏时加载相应的数据，请思考如何避免连续下拉时而产生的问题（可能是页面崩溃，也可能是巨卡无比）。一般碰到这样的面试题，防抖动机制，就能很好的解决，这方面最早的应用实践还是Twitter，开发者写了一篇博客，详细的阐述了如何解决这样的问题。那么，说道防抖动，其核心内涵在于延迟处理，也就是将一系列的事件处理程序全部延迟，保障推送近来的第一次事件处理。 12345678910event.on(&apos;scroll&apos;,function(e)&#123; var fun; return function()&#123; if(fun) clearTimeout(fun); fun = setTimeout(function()&#123; // console.log(&apos;1&apos;) &#125;,500) &#125;&#125;) 这是最常见的一种方式，如果scroll的次数较多时，可以先将真实的函数放置在定时器中。 接下来我们将它抽象一下： 123456789101112131415function de(something,delay)&#123; var fun; return function()&#123; if(fun) clearTimeout(fun); fun = setTimeout(function()&#123; something(); &#125;,delay); &#125;&#125;function scrollToList()&#123;&#125;event.on(&apos;scroll&apos;,de(scrollToList,1000))event.on(&apos;scroll&apos;,de(scrollToList,2000)) 显然这是一个弱爆了的处理，那有木有更好的方式呢？ 有，比如节流。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://walkstreet.github.io/personal-blog/categories/Javascript/"}],"tags":[{"name":"js抖动","slug":"js抖动","permalink":"https://walkstreet.github.io/personal-blog/tags/js抖动/"}]},{"title":"Vue2.0父子组件以及非父子组件如何通信","slug":"vue-component","date":"2017-04-06T02:28:29.000Z","updated":"2018-02-23T09:47:02.458Z","comments":true,"path":"2017/04/06/vue-component/","link":"","permalink":"https://walkstreet.github.io/personal-blog/personal-blog/2017/04/06/vue-component/","excerpt":"","text":"父组件传递数据给子组件父组件数据如何传递给子组件呢？可以通过props属性来实现 父组件： 123456789&lt;parent&gt; &lt;child :child-msg=&quot;msg&quot;&gt;&lt;/child&gt;//这里必须要用 - 代替驼峰&lt;/parent&gt;data()&#123; return &#123; msg: [1,2,3] &#125;;&#125; 子组件通过props来接收数据:方式1： 1props: [&apos;childMsg&apos;] 方式2： 123props: &#123; childMsg: Array //这样可以指定传入的类型，如果类型不对，会警告&#125; 方式3： 123456props: &#123; childMsg: &#123; type: Array, default: [0,0,0] //这样可以指定默认的值 &#125;&#125; 这样呢，就实现了父组件向子组件传递数据. 子组件与父组件通信那么，如果子组件想要改变数据呢？这在vue中是不允许的，因为vue只允许单向数据传递，这时候我们可以通过触发事件来通知父组件改变数据，从而达到改变子组件数据的目的. 子组件： 123456789&lt;template&gt; &lt;div @click=&quot;up&quot;&gt;&lt;/div&gt;&lt;/template&gt;methods: &#123; up() &#123; this.$emit(&apos;upup&apos;,&apos;hehe&apos;); //主动触发upup方法，&apos;hehe&apos;为向父组件传递的数据 &#125;&#125; 父组件： 12345678&lt;div&gt; &lt;child @upup=&quot;change&quot; :msg=&quot;msg&quot;&gt;&lt;/child&gt; //监听子组件触发的upup事件,然后调用change方法&lt;/div&gt;methods: &#123; change(msg) &#123; this.msg = msg; &#125;&#125; 非父子组件通信如果2个组件不是父子组件那么如何通信呢？这时可以通过eventHub来实现通信.所谓eventHub就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件. 1let Hub = new Vue(); //创建事件中心 组件1触发： 123456&lt;div @click=&quot;eve&quot;&gt;&lt;/div&gt;methods: &#123; eve() &#123; Hub.$emit(&apos;change&apos;,&apos;hehe&apos;); //Hub触发事件 &#125;&#125; 组件2接收: 123456&lt;div&gt;&lt;/div&gt;created() &#123; Hub.$on(&apos;change&apos;, () =&gt; &#123; //Hub接收事件 this.msg = &apos;hehe&apos;; &#125;);&#125; 这样就实现了非父子组件之间的通信了.原理就是把Hub当作一个中转站！","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://walkstreet.github.io/personal-blog/categories/Javascript/"}],"tags":[{"name":"Vue2.0","slug":"Vue2-0","permalink":"https://walkstreet.github.io/personal-blog/tags/Vue2-0/"},{"name":"component","slug":"component","permalink":"https://walkstreet.github.io/personal-blog/tags/component/"}]},{"title":"移动端H5页面注意事项","slug":"h5notice","date":"2017-04-05T08:11:32.000Z","updated":"2018-02-23T09:47:02.457Z","comments":true,"path":"2017/04/05/h5notice/","link":"","permalink":"https://walkstreet.github.io/personal-blog/personal-blog/2017/04/05/h5notice/","excerpt":"单个页面内容不能过多设计常用尺寸：750 x 1334 / 640 x 1134，包含了手机顶部信号栏的高度。 移动端H5活动页面常常需要能够分享到各种社交App中，常用的有 微信、QQ 等。 使用移动设备查看页面时会发现，在微信浏览器中有顶部导航栏，在qq内置浏览器里不止有 顶部导航，底部也有 操作栏（safari浏览器也一样），这些都会占用设计稿显示区域，因此在 设计环节 就需要考虑内容的多少，页面底部要 预留一定的空白，这样在微信或qq中才不会被遮住。 如下图（QQ内置浏览器）：页面设计尺寸为 750 x 1334，顶部占用 150px，底部占用 110px，共占用了 260px，因此设计稿内容应控制在 1334-260=1074px 的高度内。编写代码时，使用 Chrome 浏览器模拟设备大小，将该尺寸（750*1074）存下来，用于实时查看移动端页面效果。 如果页面已经写好了，就只能按照上面的尺寸进行内容的调整了，缩小元素间距，缩放图片大小等。","text":"单个页面内容不能过多设计常用尺寸：750 x 1334 / 640 x 1134，包含了手机顶部信号栏的高度。 移动端H5活动页面常常需要能够分享到各种社交App中，常用的有 微信、QQ 等。 使用移动设备查看页面时会发现，在微信浏览器中有顶部导航栏，在qq内置浏览器里不止有 顶部导航，底部也有 操作栏（safari浏览器也一样），这些都会占用设计稿显示区域，因此在 设计环节 就需要考虑内容的多少，页面底部要 预留一定的空白，这样在微信或qq中才不会被遮住。 如下图（QQ内置浏览器）：页面设计尺寸为 750 x 1334，顶部占用 150px，底部占用 110px，共占用了 260px，因此设计稿内容应控制在 1334-260=1074px 的高度内。编写代码时，使用 Chrome 浏览器模拟设备大小，将该尺寸（750*1074）存下来，用于实时查看移动端页面效果。 如果页面已经写好了，就只能按照上面的尺寸进行内容的调整了，缩小元素间距，缩放图片大小等。 失败经历 如果对整个页面进行缩放（使用 meta 标签），按照设计稿的比例，在高度满足的情况下宽度会偏小，两边会有白底； 就算使用 rem 作为相关间距的单位，也没有办法找到一个合适的比例在两种高度（微信/QQ）下切换，因此统一调成适配 QQ 的，这样就算在微信下有多余的空白，固定底部的引导下滑箭头也能使其不会过于突兀。 标题简短移动端浏览器导航条宽度有限，简短的标题可以使其展示完整。 二维码图片使用 img 标签引入二维码图片不要写为元素背景，不然长按没有办法触发扫描功能。应使用 img 标签引入，如下： 1&lt;img src=&quot;images/qrcode.png&quot; title=&quot;&quot; alt=&quot;&quot;&gt; 这样会阻止部分用户继续访问，从而无法很好的将用户引导到活动想要推广的产品/品牌页面，如 App 的下载页面等。因此二维码的扫描测试不能少。 举个例子，如果二维码扫描结果是应用的下载地址的话，可以使用应用宝的微下载地址来生成二维码，这是不会被“温馨提醒”的。 使用Gulp拼合图片如果打算先布局，后使用自动化工具将图片拼起来，减少请求数，需要注意：在编写 CSS 的时候，图片宽高应固定，图片拼合后才能通过定位和显示区域的宽高来展示图片。 举个例子，如果布局时 width: 100%; background-position: center;，使用工具拼合图片后，该元素区域（100% 的宽度）内会将其他图片显示出来，这不是我们想要看到的。 关于链接的分享-QQ如果将页面链接直接复制分享给其他人，在手机上接收链接消息的用户可能会看到链接的相关信息，如页面标题、描述和图片。相关信息设置方式如下： 1234&lt;title&gt;QQ中链接的标题由此处获取&lt;/title&gt;&lt;meta name=&quot;description&quot; content=&quot;QQ中链接的描述由此处获取&quot;&gt;&lt;!-- QQ默认获取的图片有可能出现缩放问题，效果不佳，可以通过如下方法进行设置 --&gt;&lt;meta itemprop=&quot;image&quot; content=&quot;http://*.*.com/static/images/share.png&quot; /&gt; 问题：即使使用了如上的 image 设置方法，还是没能显示预期图片？解决：确定下你发送的链接格式，会不会有所省略，如：somedomain/ 或者 somedomain/index，正确的应为 somedomain/index.html，才能正确解析到图片。 如果是打开链接后，在QQ内置浏览器里选择将页面分享出去，那一般不会出错。 图片压缩使用自动化工具 gulp-imagemin（教程） 来压缩图片，效果举例：101 KB =&gt; 80.7 KB。后来我使用了在线工具 Tinypng 又进行了一次压缩，效果举例：（上面使用 gulp-imagemin 压缩过的图片）80.7 KB =&gt; 38.1 KB，可见光使用自动化工具来压缩是不够的，大部分图片仍存在较大的压缩空间，可以再扔到 Tinypng 里压缩一下看看。 在线的 Tinypng 可以无限次使用，如果想要使用其 API 来进行压缩自动化的话，可以使用 gulp-tinypng 等插件，但是有每月压缩图片数量限制，每月前500张图片免费，其他收费情况参考官网说明。使用其 API 还需要获取 API Key，这里可以获取。个人觉得想要免费的话使用 API 会有数量限制，时刻惦记着数量有点心累，不如直接使用在线工具，也不麻烦~ Loading首屏 Loading，代码段分享，拿走即用~ 12345678910111213141516171819202122232425262728293031323334353637383940414243function loading()&#123; function Load()&#123;&#125; Load.prototype.loadImgs = function(urls,callback) &#123; this.urls = urls; this.imgNumbers = urls.length; this.loadImgNumbers = 0; var that =this; for(var i=0;i&lt;urls.length;i++)&#123; var obj = new Image(); obj.src = urls[i]; obj.onload = function()&#123; that.loadImgNumbers++; callback(parseInt((that.loadImgNumbers/that.imgNumbers)*100)); &#125; &#125; &#125;; var loader = new Load(); loader.loadImgs([ // 将所有需要加载的图片地址写于此处 &quot;http://domain/site/dist/img/XX.png&quot;, &quot;http://domain/site/dist/img/XX.png&quot;, &quot;http://domain/site/dist/img/XX.png&quot;, &quot;http://domain/site/dist/img/XX.png&quot;, &quot;http://domain/site/dist/img/XX.png&quot;, &quot;http://domain/site/dist/img/XX.png&quot;, &quot;http://domain/site/dist/img/XX.png&quot; ],function(percent)&#123; // 假设显示百分比的元素为 $(&quot;.percent&quot;) $(&quot;.percent&quot;).text(percent+&apos;%&apos;); // 加载结束后，隐藏相应的 loading 或遮罩 if(percent==100) &#123; $(&quot;.mask&quot;).css(&apos;display&apos;,&apos;none&apos;); &#125; &#125;);&#125;// 执行 loading 方法loading(); CSS动画属性前缀 webkit使用 CSS3 来制作动画效果的话，webkit 前缀一定记得加，要不然在某些手机下动画效果是没有的。 如下： 123456789101112131415161718192021222324252627282930-webkit-animation: f .8s 2s forwards ease-in-out;animation: f .8s 2s forwards ease-in-out;@-webkit-keyframes f &#123; 0% &#123; opacity: 0; -webkit-transform: translate3d(750px,0,0); transform: translate3d(750px,0,0) &#125; to &#123; opacity: 1; -webkit-transform: translateZ(0); transform: translateZ(0) &#125;&#125;@keyframes f &#123; 0% &#123; opacity: 0; -webkit-transform: translate3d(750px,0,0); transform: translate3d(750px,0,0) &#125; to &#123; opacity: 1; -webkit-transform: translateZ(0); transform: translateZ(0) &#125;&#125; 推荐使用自动化工具来处理未加前缀的 CSS 文件，如 gulp-autoprefixer。 Swiper.js &amp; Animate.css你只需要 Swiper.js 和 Animate.css 即可打造（简单的）移动端 H5 活动页面~Swiper 是纯 javascript 打造的滑动特效插件，面向手机、平板电脑等移动终端。Animate.css 是纯 CSS 编写而成的动画库，包含多种常见的 CSS 动画。引用 Swiper.js，同时在 Animate.css 中寻找需要的动画效果复制粘贴进 css 文件即可，完全不必引用 Animate.css。 使用 Meta 标签进行页面缩放1234567891011121314151617&lt;!-- 以下代码默认设计稿尺寸为 640 x 1134 --&gt;&lt;meta id=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=yes,initial-scale=1&quot; name=&quot;viewport&quot; /&gt;&lt;script&gt; var detectBrowser = function(name) &#123; if(navigator.userAgent.toLowerCase().indexOf(name) &gt; -1) &#123; return true; &#125; else &#123; return false; &#125; &#125;; var width = parseInt(window.screen.width); var scale = width/640; // 根据设计稿尺寸进行相应修改：640=&gt;? var userScalable = &apos;no&apos;; if(detectBrowser(&quot;qq/&quot;)) userScalable = &apos;yes&apos;; document.getElementById(&apos;viewport&apos;).setAttribute( &apos;content&apos;, &apos;target-densitydpi=device-dpi,width=640,user-scalable=&apos;+userScalable+&apos;,initial-scale=&apos; + scale); // 这里也别忘了改：640=&gt;?&lt;/script&gt; 利用 meta 标签对页面进行缩放，使得我们可以直接根据设计稿来进行页面的编写，不用再进行单位的换算等等，省却了很多麻烦。 微信二维码问题01：同一个页面里要是有两个二维码，长按扫描总是只能扫出 左侧/第一个 二维码。解决：可视区域内只能出现一个二维码。 02：使用 meta 标签缩放页面后长按二维码图片无反应。解决：使用了以下代码之后，就能长按识别二维码了~ 123456&lt;!--同一张二维码图片--&gt;&lt;!--下面这张 opacity 为 0，隐藏起来，但是实际存在，并且宽为 100%，屏幕有多大就多大--&gt;&lt; img style=&quot;right:0; top:0; height: auto;width: 100%;opacity: 0;position: absolute;&quot; src=&quot;二维码图片地址&quot;&gt;&lt;!--下面这张是呈现给用户看的--&gt;&lt; img src=&quot;二维码图片地址&quot; title=&quot;qrcode&quot; alt=&quot;qrcode&quot;&gt;&lt;!--PS: img 标签前面的空格记得去掉，这里加上空格是因为简书有 bug，针对 img 标签代码渲染会出错--&gt;","categories":[{"name":"H5","slug":"H5","permalink":"https://walkstreet.github.io/personal-blog/categories/H5/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"https://walkstreet.github.io/personal-blog/tags/移动端/"}]},{"title":"如何评价页面的性能","slug":"property","date":"2017-03-30T02:07:49.000Z","updated":"2018-02-23T09:47:02.458Z","comments":true,"path":"2017/03/30/property/","link":"","permalink":"https://walkstreet.github.io/personal-blog/personal-blog/2017/03/30/property/","excerpt":"页面加载完成之后的性能问题 重点：如果要保持在60fps以上的性能，那一帧就必须在16.7ms内完成一段js代码，或者把一些不需要同步执行的代码分拆到每一帧中。 浏览器如何渲染一个页面 这是在网上找的一张图，虽然是用来描述 performance 的 API 但是也很好的描述了浏览器是怎么处理一个页面渲染的。 这是我们在 PC 时代考虑的浏览器性能，主要在服务端响应、文档下载、文档渲染三个阶段，性能优化大部分也集中在这三个阶段。针对这部分的监控、分析非常的普遍了，在 JSTracker 上也有这个数据的分析。 为什么刚才说 PC 时代呢，除了这些指标作为前端还有需要关注的什么性能呢？ 页面加载之后的操作体验！（注：这里的加载之后近似在 onLoad 之后）","text":"页面加载完成之后的性能问题 重点：如果要保持在60fps以上的性能，那一帧就必须在16.7ms内完成一段js代码，或者把一些不需要同步执行的代码分拆到每一帧中。 浏览器如何渲染一个页面 这是在网上找的一张图，虽然是用来描述 performance 的 API 但是也很好的描述了浏览器是怎么处理一个页面渲染的。 这是我们在 PC 时代考虑的浏览器性能，主要在服务端响应、文档下载、文档渲染三个阶段，性能优化大部分也集中在这三个阶段。针对这部分的监控、分析非常的普遍了，在 JSTracker 上也有这个数据的分析。 为什么刚才说 PC 时代呢，除了这些指标作为前端还有需要关注的什么性能呢？ 页面加载之后的操作体验！（注：这里的加载之后近似在 onLoad 之后） 页面操作的流畅度在 PC 的 CPU 越来越牛逼、内存越来越大的时候，前端的代码复杂度也在上升。 以往我们都默认认为只要资源加载好了、只要资源加载快了那么我们的页面性能就是棒棒哒的，现在不再是这样。 这里涉及到两个问题： PC 端的 CPU 性能、内存的性能虽然很高了，但是前端代码也更复杂了； 除了 PC，还有无线端； 于是我们的性能指标多了一项：页面流畅度。 页面流畅度如何感知卡顿的感受会在很多地方出现，比如： 你在逛某个页面的时候愉快的的滚动鼠标滚轮，但是页面会突然的顿一下。你在打开手机上直接访问 PC 页面（或者 H5 页面）的时候，发现浏览器就像死掉了一样。拿两个 PC 页面来感受一下卡顿： 页面 1：http://codepen.io/taobaofed/pen/jbeQbN 页面 2：http://codepen.io/taobaofed/pen/JYmeYJ 很明显页面 1 比页面 2 卡顿很多。 卡顿就是这样的感觉，但是怎么来衡量这个卡顿的程度呢？ 总不能让用户直接说吧，就像上面的两个页面：有人开心的时候会说都很流畅，要是不开心的时候他会说两个都有点卡顿。这样的评价太主观了。 如何客观的度量页面卡顿程度首先要知道页面为什么会卡顿呢？ 我们还是以上面两个页面做比较，看看浏览器里面的 Timeline; 页面 1： 页面 2： 这两个页面的渲染 FPS 可以看出来，的确第一个页面很卡。一般我们要求页面要达到 60 FPS（ 60 帧/秒）。上面说到页面 2 其实也是有稍微的卡顿的，只不过比页面 1 好很多。 如果按照 60 FPS 计算，那么每一帧执行时间为 1/60s，也就是 16.7ms。 为什么页面会看起来比较卡浏览器的渲染是单线程的，在某一个时刻要么在进行 JS 运算，要么在进行 UI 渲染。不会同时进行。 如果我们的脚本在改变 UI 那么这个脚本的执行时间不要超过了 16.7ms，否则页面在这个周期中无法进行 UI 变化，那么看起来就是跳帧（卡顿）了。 如果你的页面没有改变 UI ，情况会好很多，浏览器看起来就是失去了响应，Hover 滚动都动不了了。 准备了一个简单的代码，用来说明如果脚本执行超过 16.7ms 会有什么感觉： 页面 3：http://codepen.io/taobaofed/pen/YyJJzW 点击第一个按钮，下方文字会立即变为“calculating….” 点击第二个按钮，下方的文字跳过了变为“calculating….”阶段，直接变为“calclation done”。而且按钮的 Active 状态都不会消失，直到脚本执行完成。 为什么会出现这样的结果呢？ 这个就是浏览器的单进程模式确定的，setTimeout 把要执行的任务扔到浏览器的单线程的队列尾部，线程能够有机会渲染 UI ！（图片来自参考文章 3） 第一个按钮点击之后 UI 渲染能够马上的得到运行时间，第二个按钮点击之后 UI 渲染必须要等到 long 方法执行完毕，所以看起来像是浏览器卡死了。 如何采集页面卡顿的程度目前为止，我们已经知道了什么是卡顿、卡顿的发生原因、如何在 Chrome 中查看卡顿，接下来我们要想办法用 JS 获取页面的卡顿程度。 利用上述的原理：浏览器是单线程的，如果卡顿发生了那么后面队列堆积的方法就得不到执行。 假如我们配置一个定时器，每隔一段时间 t 就向浏览器的线程队列中丢一个方法进去： 如果线程队列是空闲的，那么我们理论上可以检查到我们的方式每次都是准时的间隔 t 被调用一次；如果线程队列是繁忙的，那么这个间隔时间将是大于 t 的；试验方案有了，接下来进行试验。 12345var t = new Date();setInterval(function()&#123; console.log(new Date() - t); t = new Date();&#125;, 100); 还是刚才的页面 3， 请打开控制台看看：当点击按钮的时候控制台的 console 会停止，隔一会儿再输出数据，而且的确如我们预料的间隔时间变长了。 image 有兴趣的同学可以打开页面 1、页面 2 的控制台也可以看到数据。 接下来的事情是把这些数据收集起来，形成一个指标。这事情就好办多了： 统计页面一段时间的这些 t 值的和，可以计算出页面的拥堵程度，这个值理论上是和 CPU 的时间消耗成正比的，所以我们定义这个值为 CPU 消耗； 统计这些 t 值在什么时候开始归于平静，这个值也就是浏览器线程开始闲下来的时间，我们定义这个值为页面可操作时间； 统计一段时间这些 t 值超过某个阈值的次数，比如设置的间隔是 100ms，t 值过了 200 的次数和总次数的比。我们定义这个值为页面渲染的 CPU 占比； 数据可视化一些浏览器是不能直接看到 console 的，比如手机浏览器。于是我们提供一个小插件（bookmarklet）。 页面 4：http://codepen.io/taobaofed/pen/xwyQwd 然后打开任意页面可以看到这个： 如何优化原则是每段连续执行的 JS 都尽量在 16.7ms 内完成，主要可以按以下方案进行： 减少会引起页面重绘（redraw）的方法的调用这些值的列表如下（不完整，如果你不确定可以写个循环测试一下）： clientHeight, clientLeft, clientTop, clientWidth, focus(), getBoundingClientRect(), getClientRects(), innerText, offsetHeight, offsetLeft, offsetParent, offsetTop, offsetWidth, outerText, scrollByLines(), scrollByPages(), scrollHeight, scrollIntoView(), scrollIntoViewIfNeeded(), scrollLeft, scrollTop, scrollWidth 如果要使用尽量吧这些值缓存起来，不要再循环中直接调用。（有兴趣的同学可以对比一下页面 1 和页面 2 的区别，其实只有一行）。除了缓存还可以像页面 2 一样，直接不去获取，因为这些值可能我们是能够预测的，不要要再让浏览器计算。 将某些耗时的操作放到空闲的时候再去做（requestAnimationFrame、setTimout）如页面 3 让 UI 渲染能够有 CPU 时间执行。 但是如果你的这个耗时计算耗时太长了你可以考虑是否能将一些不是立即需要的任务分拆掉，平均的分配到各个帧。 涉及到页面的动画元素能用 GPU 最佳我们可以给某些元素加上： 1-webkit-transform: translateZ(0); 强制让浏览器用 GPU 渲染这个层，不过这样做要适量，多了也容易出问题。（参考： http://wesleyhales.com/blog/2013/10/26/Jank-Busting-Apples-Home-Page/ ） 这个监控对页面本身性能的影响由于页面被注入了这个一个定时器，可能会对页面造成影响的，虽然这个影响非常低但是还是必须要考虑： 第一层，强力优化这部分代码的性能： 在定时器中执行的任务都是纯 JS 运算，我们统计过这个部分的代码的消耗平均不到 0.04ms，占一帧时间的 0.23%。 第二层，抽样少量的数据进行数据采集，目前采样 1% 的。","categories":[{"name":"WEB","slug":"WEB","permalink":"https://walkstreet.github.io/personal-blog/categories/WEB/"}],"tags":[{"name":"性能","slug":"性能","permalink":"https://walkstreet.github.io/personal-blog/tags/性能/"}]},{"title":"图片上传预览的前端实现方法","slug":"filereader","date":"2017-03-28T09:06:49.000Z","updated":"2018-02-23T09:47:02.457Z","comments":true,"path":"2017/03/28/filereader/","link":"","permalink":"https://walkstreet.github.io/personal-blog/personal-blog/2017/03/28/filereader/","excerpt":"","text":"ExampleHTML12&lt;input type=&quot;file&quot; onchange=&quot;previewFile()&quot;&gt;&lt;br&gt;&lt;img src=&quot;&quot; height=&quot;200&quot; alt=&quot;Image preview...&quot;&gt; Javascript12345678910111213function previewFile() &#123; var preview = document.querySelector(&apos;img&apos;); var file = document.querySelector(&apos;input[type=file]&apos;).files[0]; var reader = new FileReader(); reader.addEventListener(&quot;load&quot;, function () &#123; preview.src = reader.result; &#125;, false); if (file) &#123; reader.readAsDataURL(file); &#125;&#125; Example reading multiple filesHTML12&lt;input id=&quot;browse&quot; type=&quot;file&quot; onchange=&quot;previewFiles()&quot; multiple&gt;&lt;div id=&quot;preview&quot;&gt;&lt;/div&gt; Javascript1234567891011121314151617181920212223242526272829function previewFiles() &#123; var preview = document.querySelector(&apos;#preview&apos;); var files = document.querySelector(&apos;input[type=file]&apos;).files; function readAndPreview(file) &#123; // Make sure `file.name` matches our extensions criteria if ( /\\.(jpe?g|png|gif)$/i.test(file.name) ) &#123; var reader = new FileReader(); reader.addEventListener(&quot;load&quot;, function () &#123; var image = new Image(); image.height = 100; image.title = file.name; image.src = this.result; preview.appendChild( image ); &#125;, false); reader.readAsDataURL(file); &#125; &#125; if (files) &#123; [].forEach.call(files, readAndPreview); &#125;&#125;","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://walkstreet.github.io/personal-blog/categories/Javascript/"}],"tags":[{"name":"图片预览","slug":"图片预览","permalink":"https://walkstreet.github.io/personal-blog/tags/图片预览/"}]},{"title":"Javascript 严格模式详解","slug":"strict","date":"2017-03-28T06:35:11.000Z","updated":"2018-02-23T09:47:02.458Z","comments":true,"path":"2017/03/28/strict/","link":"","permalink":"https://walkstreet.github.io/personal-blog/personal-blog/2017/03/28/strict/","excerpt":"概述除了正常运行模式，ECMAscript 5添加了第二种运行模式：”严格模式”（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。 设立”严格模式”的目的，主要有以下几个： - 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; - 消除代码运行的一些不安全之处，保证代码运行的安全； - 提高编译器效率，增加运行速度； - 为未来新版本的Javascript做好铺垫。 “严格模式”体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。 另一方面，同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。掌握这些内容，有助于更细致深入地理解Javascript，让你变成一个更好的程序员。 本文将对”严格模式”做详细介绍。","text":"概述除了正常运行模式，ECMAscript 5添加了第二种运行模式：”严格模式”（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。 设立”严格模式”的目的，主要有以下几个： - 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; - 消除代码运行的一些不安全之处，保证代码运行的安全； - 提高编译器效率，增加运行速度； - 为未来新版本的Javascript做好铺垫。 “严格模式”体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。 另一方面，同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。掌握这些内容，有助于更细致深入地理解Javascript，让你变成一个更好的程序员。 本文将对”严格模式”做详细介绍。 进入标志进入”严格模式”的标志，是下面这行语句： “use strict”; 老版本的浏览器会把它当作一行普通字符串，加以忽略。 如何调用“严格模式”有两种调用方法，适用于不同的场合。 3.1 针对整个脚本文件将”use strict”放在脚本文件的第一行，则整个脚本都将以”严格模式”运行。如果这行语句不在第一行，则无效，整个脚本以”正常模式”运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意。(严格地说，只要前面不是产生实际运行结果的语句，”use strict”可以不在第一行，比如直接跟在一个空的分号后面。) 1234567&lt;script&gt;&quot;use strict&quot;;console.log(&quot;这是严格模式。&quot;);&lt;/script&gt;&lt;script&gt;console.log(&quot;这是正常模式。&quot;);kly, it&apos;s almost 2 years ago now. I can admit it now - I run it on my school&apos;s network that has about 50 computers.&lt;/script&gt; 上面的代码表示，一个网页中依次有两段Javascript代码。前一个script标签是严格模式，后一个不是。 3.2 针对单个函数将”use strict”放在函数体的第一行，则整个函数以”严格模式”运行。 1234567function strict()&#123; &quot;use strict&quot;; return &quot;这是严格模式。&quot;;&#125;function notStrict() &#123; return &quot;这是正常模式。&quot;;&#125; 3.3 脚本文件的变通写法因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。 1234(function ()&#123; &quot;use strict&quot;; // some code here&#125;)(); 语法和行为改变严格模式对Javascript的语法和行为，都做了一些改变。 4.1 全局变量显式声明在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。 1234&quot;use strict&quot;;v = 1; // 报错，v未声明for(i = 0; i &lt; 2; i++) &#123; // 报错，i未声明&#125; 因此，严格模式下，变量都必须先用var命令声明，然后再使用。 4.2 静态绑定Javascript语言的一个特点，就是允许”动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。具体来说，涉及以下几个方面。 （1）禁止使用with语句因为with语句无法在编译时就确定，属性到底归属哪个对象。 12345&quot;use strict&quot;;var v = 1;with (o)&#123; // 语法错误 v = 2;&#125; （2）创设eval作用域正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval作用域。正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。 1234&quot;use strict&quot;;var x = 2;console.info(eval(&quot;var x = 5; x&quot;)); // 5console.info(x); // 2 4.3 增强的安全措施（1）禁止this关键字指向全局对象 123456789function f()&#123; return !this;&#125; // 返回false，因为&quot;this&quot;指向全局对象，&quot;!this&quot;就是falsefunction f()&#123; &quot;use strict&quot;; return !this;&#125; // 返回true，因为严格模式下，this的值为undefined，所以&quot;!this&quot;为true。 因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。 12345function f()&#123; &quot;use strict&quot;; this.a = 1;&#125;;f();// 报错，this未定义 （2）禁止在函数内部遍历调用栈 123456function f1()&#123; &quot;use strict&quot;; f1.caller; // 报错 f1.arguments; // 报错&#125;f1(); 4.4 禁止删除变量严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。 12345678&quot;use strict&quot;;var x;delete x; // 语法错误var o = Object.create(null, &#123;&apos;x&apos;: &#123; value: 1, configurable: true&#125;&#125;);delete o.x; // 删除成功 4.5 显式报错正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。 1234&quot;use strict&quot;;var o = &#123;&#125;;Object.defineProperty(o, &quot;v&quot;, &#123; value: 1, writable: false &#125;);o.v = 2; // 报错 严格模式下，对一个使用getter方法读取的属性进行赋值，会报错。 12345&quot;use strict&quot;;var o = &#123; get v() &#123; return 1; &#125;&#125;;o.v = 2; // 报错 严格模式下，对禁止扩展的对象添加新属性，会报错。 1234&quot;use strict&quot;;var o = &#123;&#125;;Object.preventExtensions(o);o.v = 1; // 报错 严格模式下，删除一个不可删除的属性，会报错。 12&quot;use strict&quot;;delete Object.prototype; // 报错 4.6 重名错误严格模式新增了一些语法错误。 （1）对象不能有重名的属性 正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。 12345&quot;use strict&quot;;var o = &#123; p: 1, p: 2&#125;; // 语法错误 （2）函数不能有重名参数 正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。 1234&quot;use strict&quot;;function f(a, a, b) &#123; // 语法错误 return ;&#125; 4.8 arguments对象的限制arguments是函数的参数对象，严格模式对它的使用做了限制。 （1）不允许对arguments赋值 123456&quot;use strict&quot;;arguments++; // 语法错误var obj = &#123; set p(arguments) &#123; &#125; &#125;; // 语法错误try &#123; &#125; catch (arguments) &#123; &#125; // 语法错误function arguments() &#123; &#125; // 语法错误var f = new Function(&quot;arguments&quot;, &quot;&apos;use strict&apos;; return 17;&quot;); // 语法错误 （2）arguments不再追踪参数的变化 1234567891011function f(a) &#123; a = 2; return [a, arguments[0]];&#125;f(1); // 正常模式为[2,2]function f(a) &#123; &quot;use strict&quot;; a = 2; return [a, arguments[0]];&#125;f(1); // 严格模式为[2,1] （3）禁止使用arguments.callee 这意味着，你无法在匿名函数内部调用自身了。 123&quot;use strict&quot;;var f = function() &#123; return arguments.callee; &#125;;f(); // 报错 4.9 函数必须声明在顶层将来Javascript的新版本会引入”块级作用域”。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。 1234567&quot;use strict&quot;;if (true) &#123; function f() &#123; &#125; // 语法错误&#125;for (var i = 0; i &lt; 5; i++) &#123; function f2() &#123; &#125; // 语法错误&#125; 4.10 保留字为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。使用这些词作为变量名将会报错。 使用这些词作为变量名将会报错。 1234function package(protected) &#123; // 语法错误 &quot;use strict&quot;; var implements; // 语法错误&#125; 此外，ECMAscript第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的const保留字，也是不能作为变量名的。 转自《阮一峰的网络日志》","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://walkstreet.github.io/personal-blog/categories/Javascript/"}],"tags":[{"name":"严格模式","slug":"严格模式","permalink":"https://walkstreet.github.io/personal-blog/tags/严格模式/"}]},{"title":"Javascript之this详解","slug":"js-this","date":"2017-03-28T02:31:58.000Z","updated":"2018-02-23T09:47:02.458Z","comments":true,"path":"2017/03/28/js-this/","link":"","permalink":"https://walkstreet.github.io/personal-blog/personal-blog/2017/03/28/js-this/","excerpt":"JavaScript作为一种脚本语言身份的存在，因此被很多人认为是简单易学的。然而情况恰恰相反，JavaScript支持函数式编程、闭包、基于原型的继承等高级功能。由于其运行期绑定的特性，JavaScript 中的 this 含义要丰富得多，它可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式。JavaScript中函数的调用有以下几种方式：作为对象方法调用，作为函数调用，作为构造函数调用，和使用 apply 或 call 调用。本文就采撷些例子以浅显说明在不同调用方式下的不同含义。 全局的this全局this一般指向全局对象，浏览器中的全局对象就是 window。例如：12345console.log(this.document === document); //trueconsole.log(this === window); //truethis.a = 91;console.log(window.a); //91","text":"JavaScript作为一种脚本语言身份的存在，因此被很多人认为是简单易学的。然而情况恰恰相反，JavaScript支持函数式编程、闭包、基于原型的继承等高级功能。由于其运行期绑定的特性，JavaScript 中的 this 含义要丰富得多，它可以是全局对象、当前对象或者任意对象，这完全取决于函数的调用方式。JavaScript中函数的调用有以下几种方式：作为对象方法调用，作为函数调用，作为构造函数调用，和使用 apply 或 call 调用。本文就采撷些例子以浅显说明在不同调用方式下的不同含义。 全局的this全局this一般指向全局对象，浏览器中的全局对象就是 window。例如：12345console.log(this.document === document); //trueconsole.log(this === window); //truethis.a = 91;console.log(window.a); //91 一般函数的this1234function f1 () &#123; return this;&#125;console.log(f1() === window);//true, global object 可以看到一般函数的 this 也指向 window，在 nodeJS 中为 global object 12345function f2 () &#123; &quot;use strict&quot;;//使用严格模式 return this;&#125;console.log(f1() === undefined);//true 严格模式中，函数的 this 为 undefined,因为严格模式禁止this关键字指向全局对象；对于js“严格模式”具体可以看阮一峰先生的Javascript 严格模式详解 作为对象方法的函数的 this1234567var o = &#123; prop: 37, f: function() &#123; return this.prop; &#125;&#125;;console.log(o.f()); // 37 上述代码通过字面量创建对象 o。f 为对象 o 的方法。这个方法的 this 指向这个对象，在这里即对象 o。 12345678var o = &#123; prop: 37&#125;;function independent() &#123; return this.prop;&#125;o.f = independent;console.log(o.f()); // 37 上面的代码，创建了对象 o，但是没有给对象 o，添加方法。而是通过 o.f = independent 临时添加了方法属性。这样这个方法中的 this 同样也指向这个对象 o。 作为函数调用函数也可以直接被调用，此时 this 绑定到全局对象。在浏览器中，window 就是该全局对象。比如下面的例子：函数被调用时，this被绑定到全局对象，接下来执行赋值语句，相当于隐式的声明了一个全局变量，这显然不是调用者希望的。 12345function makeNoSense(x) &#123; this.x = x;&#125;makeNoSense(5);x;// x 已经成为一个值为 5 的全局变量 对于内部函数，即声明在另外一个函数体内的函数，这种绑定到全局对象的方式会产生另外一个问题。以下面moveTo方法为例，内定义两个函数，分别将 x，y 坐标进行平移。结果可能出乎大家意料，不仅 point 对象没有移动，反而多出两个全局变量 x，y。 123456789101112131415161718192021var point = &#123; x : 0, y : 0, moveTo : function(x, y) &#123; // 内部函数 var moveX = function(x) &#123; this.x = x;//this 绑定到了哪里？ &#125;; // 内部函数 var moveY = function(y) &#123; this.y = y;//this 绑定到了哪里？ &#125;; moveX(x); moveY(y); &#125;&#125;;point.moveTo(1, 1);console.log(point.x) //0console.log(point.x) //0console.log(x) //1console.log(y) //1 这属于 JavaScript 的设计缺陷，正确的设计方式是内部函数的this应该绑定到其外层函数对应的对象上，为了规避这一设计缺陷，聪明的JavaScript程序员想出了变量替代的方法，约定俗成，该变量一般被命名为 that。 对象原型链上的this123456789var o = &#123; f: function() &#123; return this.a + this.b; &#125;&#125;;var p = Object.create(o);p.a = 1;p.b = 2;console.log(p.f()); //3 通过 var p = Object.create(o) 创建的对象，p 是基于原型 o 创建出的对象。p 的原型是 o，调用 f() 的时候是调用了 o 上的方法 f()，这里面的 this 是可以指向当前对象的，即对象 p。 get/set 方法与 this12345678910111213141516function modulus() &#123; return Math.sqrt(this.re * this.re + this.im * this.im);&#125;var o = &#123; re: 1, im: -1, get phase() &#123; return Math.atan2(this.im, this.re); &#125;&#125;;Object.defineProperty(o, &apos;modulus&apos;, &#123; get: modulus, enumerable: true, configurable: true&#125;);console.log(o.phase, o.modulus); // -0.78 1.4142 get/set 方法中的 this 也会指向 get/set 方法所在的对象的。 构造器中的 this12345function MyClass() &#123; this.a = 25;&#125;var o = new MyClass();console.log(o.a); //25 new MyClass() 的时候，MyClass()中的 this 会指向一个空对象，这个对象的原型会指向 MyClass.prototype。MyClass()没有返回值或者返回为基本类型时，默认将 this 返回。 12345678function C2() &#123; this.a = 26; return &#123; a: 24 &#125;;&#125;o = new C2();console.log(o.a); //24 因为返回了对象，将这个对象作为返回值 call/apply 方法与 this1234567891011121314151617function add(c, d) &#123; return this.a + this.b + c + d;&#125;var o = &#123; a: 1, b: 3&#125;;add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34function bar() &#123; console.log(Object.prototype.toString.call(this));&#125;bar.call(7); // &quot;[object Number]&quot;bar.call(); //[object global]bar.call(&quot;7&quot;);//[object String]bar.call(true);//[object Boolean]console.log(add.call(o,5,7));//16 bind方法与this12345678910111213function f() &#123; return this.a;&#125;var g = f.bind(&#123; a: &quot;test&quot;&#125;);console.log(g()); // testvar o = &#123; a: 37, f: f, g: g&#125;;console.log(o.f(), o.g()); // 37, test 绑定之后再调用时，仍然会按绑定时的内容走，所以 o.g() 结果是 test JavaScript中this的些许看似怪异现象1234567&lt;body&gt; &lt;!--JavaScript伪协议和内联事件对于this的指向不同--&gt; &lt;a href=&quot;#&quot; onclick=&quot;alert(this.tagName);&quot;&gt;click me&lt;/a&gt; &lt;!--弹出A--&gt; &lt;a href=&quot;javascript:alert(this.tagName);&quot;&gt;click me&lt;/a&gt; &lt;!--弹出undefined--&gt; &lt;a href=&quot;javascript:alert(this==window);&quot;&gt;click me&lt;/a&gt; &lt;!--弹出true--&gt; &lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;this demo&quot; name=&quot;button&quot;/&gt;&lt;/body&gt; 12345678var name = &apos;somebody&apos;;var angela = &#123; name: &apos;angela&apos;, say: function () &#123; alert(&quot;I&apos;m &quot; + this.name); &#125;&#125;;var btn = document.getElementById(&apos;btn&apos;); setTimeout和setInterval也会改变this的指向123angela.say();//I&apos;m angelasetTimeout(angela.say, 1000); //I&apos;m somebodysetInterval(angela.say, 1000); //I&apos;m somebody 这是因为setTimeout等函数内this默认的指向是Window。这一点类似于曾探所写的《JavaScript设计模式与开发实践》中提到的丢失的this。看下面代码： 12345678910var obj =&#123; myName: &apos;jeff&apos;, getName: function()&#123; return this.myName; &#125;&#125;;console.log(obj.getName()); //jeffvar getName2 = obj.getName;console.log( getName2() ); //undefined//调用getName2时是普通函数方式，this指向全局window，故而结果是undefined； on…也会改变this的指向12angela.say(); //I&apos;m angelabtn.onclick = angela.say; //I&apos;m button click等回调也会改变this指向12$(&quot;#btn&quot;).click = angela.say; // I&apos;m button$(&quot;#btn&quot;).click(angela.say); // I&apos;m button 如果在say中用了this，this会绑定在angela上么？显然这里不是，赋值以后，函数是在回调中执行的，this会绑定到$(“#btn”)元素上。这个函数被完整复制到onclick属性（现在成为了函数）。因此如果这个even thandler被执行，this将指向HTML元素;因此，结果显示的是”I’m button”。而，匿名函数可以调整this指向,EG: 123$(&quot;#btn&quot;).click(function()&#123; angela.say(); //I&apos;m angela&#125;); 这是JavaScript新手们经常犯的一个错误，为了避免这种错误，许多JavaScript框架都提供了手动绑定 this 的方法。比如Dojo就提供了lang.hitch，该方法接受一个对象和函数作为参数，返回一个新函数，执行时this绑定到传入的对象上。使用 Dojo，可以将上面的例子改为： 1button.onclick = lang.hitch(angela, angela.say); 其实在我们使用比较多的jQuery也提供了对应的解决方案：jQuery.proxy(function, scope).返回一个新函数，并且这个函数始终保持了特定的作用域。其作用跟Dojo就提供了lang.hitch类似，其中有一例如下： 1234567891011121314&lt;div id=&apos;test&apos;&gt;Click Here&lt;\\/div&gt;var obj = &#123; name: &quot;John&quot;, test: function() &#123; alert( this.name ); $(&quot;#test&quot;).unbind(&quot;click&quot;, obj.test); &#125;&#125;;$(&quot;#test&quot;).click( jQuery.proxy( obj, &quot;test&quot; ) );//强制设置函数的作用域，让this指向obj而不是#test对象。// 以下代码跟上面那句是等价的:// $(&quot;#test&quot;).click( jQuery.proxy( obj.test, obj ) );// 可以与单独执行下面这句做个比较。// $(&quot;#test&quot;).click( obj.test ); 在新版的 JavaScript 中，已经提供了内置的 bind 方法供大家使用。 12345setTimeout(function () &#123; angela.say(); &#125;, 1000); //I&apos;m angelasetInterval(function () &#123; angela.say(); &#125;, 1000) //I&apos;m angelabtn.onclick = function () &#123; angela.say(); &#125;; //I&apos;m angelasetTimeout(function () &#123; alert(this == window); &#125;, 1000);//truebtn.onclick = function () &#123; alert(this == btn); &#125;//true 123456789$(&quot;#btn&quot;).click(function()&#123; if(window == this)&#123; alert(&quot;window == this&quot;); &#125;else&#123; alert(&quot;window != this&quot;) //弹出来 &#125; alert(this.name); // button angela.say(); //I&apos;m angela&#125;); 将this指向的对象保存到变量(一般用that)123456789101112var mydemo = &#123; name: &apos;angela&apos;, say: function () &#123; alert(&quot;I&apos;m &quot; + this.name); &#125;, init: function () &#123; var that = this; document.getElementById(&apos;btn&apos;).onclick = function () &#123; that.say(); //弹出Alert：I&apos;m angela this.say(); //这儿报错: undefined is not a function (evaluating &apos;this.say()&apos;) &#125; &#125;&#125;;mydemo.init(); 第三方库or框架中的this比如，使用backbone框架中events时间回调中的this，其指向的就是对应的视图，而不是Dom元素，因为该回调时通过events哈希绑定的，实质上也是自对应视图那里callback到对应的函数; Javascript中的eval 方法JavaScript 中的 eval 方法可以将字符串转换为 JavaScript 代码，使用 eval 方法时，this 指向哪里呢？答案很简单，看谁在调用 eval 方法，调用者的执行环境（ExecutionContext）中的 this 就被 eval 方法继承下来了。(悪，还没用过,有待实践下)！但是：在严格模式之下，eval的作用域也被改变了。正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。 1234&quot;use strict&quot;;var x = 2;console.info(eval(&quot;var x = 5; x&quot;)); // 5console.info(x); // 2 Es6箭头函数中的 this随着时间的推移，Es6越发会成为新的主流，当然在之后肯定又有新的譬如正在制定的Es7等等；而对于本文this 相关的，这Es6备受关注的的箭头函数( 例如()=&gt;{} )，就很有必要谈及了。这种很简洁的使用，让函数内部this具有了上下文相同的执行环境；再也不写 var that = this 这样蹩脚的东东了（当然 that 在很多童鞋笔下可能是 _this , self等等，我的天哪）。也不用借助 eval 或者 $proxy(obj.xx ,obj) 这样蹩脚的第三方替代办法，酷爽。至于这箭头函数内部的this到底为何物，一两句也谈不清楚，可参见 ES6 箭头函数中的 this？你可能想多了（翻译），一探究竟。[update: 16-04-27]后记：由于javascript的动态性（解释执行，当然也有简单的预编译过程），this的指向在运行时才确定，因此在只要足够留心其运行时的上下文，即可无痛挥霍this的强大。上面列举了这么些许，也是要说明另一个问题：即便知道了这个本质，到底还是需要了解各种环境的差异，方可运用自如。比如这篇JavaScript:万恶的this拿命来（一）文章还谈及：node脚本，还有REPL(“读取-求值-输出”循环（Read-Eval-Print Loop，简称REPL）)中使用this的些许区别，可以一览。","categories":[{"name":"Javascript","slug":"Javascript","permalink":"https://walkstreet.github.io/personal-blog/categories/Javascript/"}],"tags":[{"name":"this","slug":"this","permalink":"https://walkstreet.github.io/personal-blog/tags/this/"},{"name":"作用域","slug":"作用域","permalink":"https://walkstreet.github.io/personal-blog/tags/作用域/"}]},{"title":"Webpack 入门指迷","slug":"webpack","date":"2017-03-27T06:46:16.000Z","updated":"2018-02-23T09:47:02.458Z","comments":true,"path":"2017/03/27/webpack/","link":"","permalink":"https://walkstreet.github.io/personal-blog/personal-blog/2017/03/27/webpack/","excerpt":"Webpack 是什么?Github：https://github.com/webpackWebpack 是德国开发者 Tobias Koppers 开发的模块加载器Instagram 工程师认为这个方案很棒, 似乎还把作者招过去了在 Webpack 当中, 所有的资源都被当作是模块, js, css, 图片等等..因此, Webpack 当中 js 可以引用 css, css 中可以嵌入图片 dataUrl","text":"Webpack 是什么?Github：https://github.com/webpackWebpack 是德国开发者 Tobias Koppers 开发的模块加载器Instagram 工程师认为这个方案很棒, 似乎还把作者招过去了在 Webpack 当中, 所有的资源都被当作是模块, js, css, 图片等等..因此, Webpack 当中 js 可以引用 css, css 中可以嵌入图片 dataUrl 对应各种不同文件类型的资源, Webpack 有对应的模块 loader比如 CoffeeScript 用的是 coffee-loader, 其他还有很多:http://webpack.github.io/docs/list-of-loaders.html大致的写法也就这样子:123456module: &#123; loaders: [ &#123; test: /\\.coffee$/, loader: &apos;coffee-loader&apos; &#125;, &#123; test: /\\.js$/, loader: &apos;jsx-loader?harmony&apos; &#125; // loaders can take parameters as a querystring ]&#125;, CommonJS 与 AMD 支持Webpack 对 CommonJS 的 AMD 的语法做了兼容, 方便迁移代码 不过实际上, 引用模块的规则是依据 CommonJS 来的12require(&apos;lodash&apos;) // 从模块目录查找require(&apos;./file&apos;) // 按相对路径查找 AMD 语法中, 也要注意, 是按 CommonJS 的方案查找的123define (require, exports. module) -&gt; require(&apos;lodash&apos;) # commonjs 当中这样是查找模块的 require(&apos;./file&apos;) 特殊模块的 Shim比如某个模块依赖 window.jQuery, 需要从 npm 模块中将 jquery 挂载到全局Webpack 有不少的 Shim 的模块, 比如 expose-loader 用于解决这个问题https://github.com/webpack/docs/wiki/shimming-modules其他比如从模块中导出变量…具体说明有点晦涩.. 手头的两个例子, 比如我们用到 Pen 这个模块,这个模块对依赖一个 window.jQuery, 可我手头的 jQuery 是 CommonJS 语法的而 Pen 对象又是生成好了绑在全局的, 可是我又需要通过 require(‘pen’) 获取变量最终的写法就是做 Shim 处理直接提供支持:12&#123;test: require.resolve(&apos;jquery&apos;), loader: &apos;expose?jQuery&apos;&#125;,&#123;test: require.resolve(&apos;pen&apos;), loader: &apos;exports?window.Pen&apos;&#125;, 基本的使用安装 webpack 模块之后, 可是使用 webpack 这个命令行工具可以使用参数, 也可以配置 webpack.config.js 文件直接运行 webpack 调用建议按照 Peter Hunt 给的教程走一遍, 基本的功能都会用到了https://github.com/petehunt/webpack-howto 简单的例子就是这样一个文件, 可以把 ./main.js 作为入口打包 bundle.js:1234567// webpack.config.jsmodule.exports = &#123; entry: &apos;./main.js&apos;, output: &#123; filename: &apos;bundle.js&apos; &#125;&#125;; 查找依赖Webpack 是类似 Browserify 那样在本地按目录对依赖进行查找的可以构造一个例子, 用 –display-error-details 查看查找过程,例子当中 resolve.extensions 用于指明程序自动补全识别哪些后缀,注意一下, extensions 第一个是空字符串! 对应不需要后缀的情况.12345678910// webpack.config.jsmodule.exports = &#123; entry: &apos;./a.js&apos;, output: &#123; filename: &apos;b.js&apos; &#125;, resolve: &#123; extensions: [&apos;&apos;, &apos;.coffee&apos;, &apos;.js&apos;] &#125;&#125; 12// a.jsrequire(&apos;./c&apos;) 123456789101112131415161718192021➤➤ webpack --display-error-detailsHash: e38f7089c39a1cf34032Version: webpack 1.5.3Time: 54msAsset Size Chunks Chunk Names b.js 1646 0 [emitted] main [0] ./a.js 15 &#123;0&#125; [built] [1 error]ERROR in ./a.jsModule not found: Error: Cannot resolve &apos;file&apos; or &apos;directory&apos; ./c in /Users/chen/Drafts/webpack/detailsresolve file /Users/chen/Drafts/webpack/details/c doesn&apos;t exist /Users/chen/Drafts/webpack/details/c.coffee doesn&apos;t exist /Users/chen/Drafts/webpack/details/c.js doesn&apos;t existresolve directory /Users/chen/Drafts/webpack/details/c doesn&apos;t exist (directory default file) /Users/chen/Drafts/webpack/details/c/package.json doesn&apos;t exist (directory description file)[/Users/chen/Drafts/webpack/details/c][/Users/chen/Drafts/webpack/details/c.coffee][/Users/chen/Drafts/webpack/details/c.js] @ ./a.js 2:0-14 ./c 是不存在, 从这个错误信息当中我们大致能了解 Webpack 是怎样查找的大概就是会尝试各种文件名, 会尝试作为模块, 等等一般模块就是查找 node_modules, 但这个也是能被配置的:http://webpack.github.io/docs/configuration.html#resolve-modulesdirectories CSS 及图片的引用英文的教程上有明确的例子:https://github.com/petehunt/webpack-howto#5-stylesheets-and-images12345require(&apos;./bootstrap.css&apos;);require(&apos;./myapp.less&apos;);var img = document.createElement(&apos;img&apos;);img.src = require(&apos;./glyph.png&apos;); 上边的是 JavaScript 代码, CSS 跟 LESS, 还有图片, 被直接引用了实际上 CSS 被转化为 &lt; style > 标签, 而图片可能被转化成 base64 格式的 dataUrl但是要主要在 webpack.config.js 文件写好对应的 loader:12345678910111213141516// webpack.config.jsmodule.exports = &#123; entry: &apos;./main.js&apos;, output: &#123; path: &apos;./build&apos;, // This is where images AND js will go publicPath: &apos;http://mycdn.com/&apos;, // This is used to generate URLs to e.g. images filename: &apos;bundle.js&apos; &#125;, module: &#123; loaders: [ &#123; test: /\\.less$/, loader: &apos;style-loader!css-loader!less-loader&apos; &#125;, // use ! to chain loaders &#123; test: /\\.css$/, loader: &apos;style-loader!css-loader&apos; &#125;, &#123;test: /\\.(png|jpg)$/, loader: &apos;url-loader?limit=8192&apos;&#125; // inline base64 URLs for &lt;=8k images, direct URLs for the rest ] &#125;&#125;; url-loader稍微啰嗦一下这个 loader, 这个 loader 实际上是对 file-loader 的封装https://github.com/webpack/url-loader比如 CSS 文件当中有这样的引用:123.demo &#123; background-image: url(&apos;a.png&apos;);&#125; 那么对应这样的 loader 配置就能把 a.png 抓出来,并且按照文件大小, 或者转化为 base64, 或者单独作为文件:12345module: &#123; loaders: [ &#123;test: /\\.(png|jpg)$/, loader: &apos;url-loader?limit=8192&apos;&#125; // inline base64 URLs for &lt;=8k images, direct URLs for the rest ]&#125; 上边 ? 后边的 query 有两种写法, 可以看下文档:http://webpack.github.io/docs/using-loaders.html#query-parameters file-loader 由于 url-loader 是对 file-loader 的一个封装, 以因此带有后者一些功能:https://github.com/webpack/file-loader比如说, file-loader 有不弱的定义文件名的功能1require(&quot;file?name=[path][name].[ext]?[hash]!./dir/file.png&quot;) 对应 url-loader 当中如果文件超出体积, 就给一个这样的文件名.. 打成多个包有时考虑类库代码的缓存, 我们会考虑打成多个包, 这样不难比如下边的配置, 首先 entry 有多个属性, 对应多个 JavaScript 包,然后 commonsPlugin 可以用于分析模块的共用代码, 单独打一个包出来:https://github.com/petehunt/webpack-howto#8-optimizing-common-codehttps://github.com/webpack/docs/wiki/optimization#multi-page-app123456789101112131415// webpack.config.jsvar webpack = require(&apos;webpack&apos;);var commonsPlugin = new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;);module.exports = &#123; entry: &#123; Profile: &apos;./profile.js&apos;, Feed: &apos;./feed.js&apos; &#125;, output: &#123; path: &apos;build&apos;, filename: &apos;[name].js&apos; // Template based on keys in entry above &#125;, plugins: [commonsPlugin]&#125;; 对文件做 revision这个在文档上做了说明, 可以自动生成 js 文件的 Hash:http://webpack.github.io/docs/long-term-caching.html1output: &#123; chunkFilename: &quot;[chunkhash].bundle.js&quot; &#125; 12345678910plugins: [ function() &#123; this.plugin(&quot;done&quot;, function(stats) &#123; require(&quot;fs&quot;).writeFileSync( path.join(__dirname, &quot;...&quot;, &quot;stats.json&quot;), JSON.stringify(stats.toJson())); ) &#125;); &#125;] 同时, 可以注册事件, 拿到生成的带 Hash 的文件的一个表但是拿到那个表之后, 就需要自己写代码进行替换了.. 这有点麻烦官网的 Issue 里提到个办法是生成 HTML 时引用 stats.json 的数据,我此前的方案是生成 HTML 之后再进行替换, 相对赖上生成时写入更好一些 上线 另一份配置文件 用 webpack –config webpack.min.js 指定另一个名字的配置文件这个文件当中可以写不一样配置, 专门用于代码上线时的操作 压缩 JavaScript 因为代码都是 JavaScript, 所以压缩就很简单了, 加上一行 plugin 就好了http://webpack.github.io/docs/list-of-plugins.html#uglifyjsplugin123plugins: [ new webpack.optimize.MinChunkSizePlugin(minSize)] 压缩 React React 官方提供的代码是已经合并的, 这个是 Webpack 不推荐的用法, 在合并话的代码上进行定制有点麻烦, Webpack 提供了设置环境变量来优化代码的方案:12345new webpack.DefinePlugin(&#123; &quot;process.env&quot;: &#123; NODE_ENV: JSON.stringify(&quot;production&quot;) &#125;&#125;) https://github.com/webpack/webpack/issues/292#issuecomment-44804366 CDN 替换 CDN 这个工作, Webpack 也内置了, 设置 output.publicPath 即可http://webpack.github.io/docs/configuration.html#output-publicpath 代码热替换虽然文档上写得挺复杂的, 但如果只是简单的功能还是很容易的 第一步, 把 ‘webpack/hot/dev-server‘ 加入到打包的代码当中,这个是对应 node_modules/webpack/ 目录当中的文件的: 1234entry: &#123; main: [&apos;webpack/hot/dev-server&apos;, &apos;./main&apos;], vendor: [&apos;lodash&apos;, &apos;./styles&apos;]&#125;, 启动服务器, 比如我是这样子的1webpack-dev-server --hot --quiet 正常可以看到提示说服务器已经起来了http://localhost:8080/webpack-dev-server/如果有 index.html 的话, 直接访问网址应该就能开始调试了 React Hot Replace调试 React 的话, 有这样的工具简直是神器了, 甚至不用刷新页面!http://gaearon.github.io/react-hot-loader/getstarted/12345entry: [ &apos;webpack-dev-server/client?http://0.0.0.0:8080&apos;, // WebpackDevServer host and port &apos;webpack/hot/only-dev-server&apos;, &apos;./scripts/index&apos; // Your appʼs entry point] 我特意问了下作者为什么上边配置看起来不一样..https://github.com/gaearon/react-hot-loader/issues/73#issuecomment-73679446回复大致说是为了避免自动的强制刷新他用了特别的写法..关于这项功能具体如何实现, 我没有深入了解过… hot replace 非静态的网页上边 localhost:8080 的方案并不适合复杂的页面,于是文档上给出了一套稍微复杂一些的方案, 用来配合其他的服务器调试大致的思路是这样的: Webpack 打包生成的那些静态资源用服务器 A 进行 serve这里说的 A 就是上边说的这个: 1webpack-dev-server --hot --quiet 我们的 HTML 由 B 渲染, B 会引用 A serve 的静态资源B 生成的页面当中加上类似这样的代码: 1&lt;script src=&quot;http://&lt;A 的地址&gt;/assets/bundle.js&quot;&gt; 还可能要设置一下 output.publicPath, 把所有静态资源指向 A 文件修改时, webpack-dev-server 通过 socket.io 通知客户端更新 这个步骤在文档上写得有点难懂, 大概要多尝试几次才行, 我也弄错很多次http://webpack.github.io/docs/webpack-dev-server.html 单独打包 CSS因为公司里有这个需要求, 强制把 CSS 从 js 文件当中独立出来.官方文档是以插件的形式做的:http://webpack.github.io/docs/stylesheets.html#separate-css-bundle参考文档但是注意一下函数参数, 第一第二个参数是有区别的, 比如这样用: 1ExtractTextPlugin.extract(&apos;style-loader&apos;, &apos;css!less&apos;) 第一个参数是编译好以后的代码用的, 第二个参数是编译到源代码用的.. 有点难懂.. 总结Webpack 的报错挺不友好的, 最初的时候我看着模块找不到没法搞明白 这种时候把中间过程打印出来看是不错的选择: webpack –display-error-details另一个报错是没有对应 loader 的提示.. log 可能很长找不到重点我建议是先自己去想想什么地方需要考虑 loader 吧… 可能就知道了我还遇到就是源码里有使用 dataUrl 导致报错… 确实奇怪了 不说这些坑的话, Webpack 我认为是我目前接触到最好的前端开发方案很多功能之前 FIS 文档上看到过, 但 FIS 相对重一些我始终没上手而 Webpack 一上来就绕过了此前公司用 RequireJS 打包时遇到的各种问题 如果去扫 Webpack 的文档的话, 还有很多功能我完全没涉及到..http://webpack.github.io/docs/","categories":[{"name":"自动化构建","slug":"自动化构建","permalink":"https://walkstreet.github.io/personal-blog/categories/自动化构建/"}],"tags":[{"name":"Webpack","slug":"Webpack","permalink":"https://walkstreet.github.io/personal-blog/tags/Webpack/"}]}]}